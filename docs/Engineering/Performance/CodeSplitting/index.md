# ä»£ç åˆ†å‰²

## ç®€ä»‹
### ğŸš€ ä»€ä¹ˆæ˜¯ä»£ç åˆ†å‰²

ä»£ç åˆ†å‰²ï¼ˆCode Splittingï¼‰æ˜¯ä¸€ç§ä¼˜åŒ–æŠ€æœ¯ï¼Œå°†åº”ç”¨ç¨‹åºçš„ä»£ç æ‹†åˆ†æˆå¤šä¸ªè¾ƒå°çš„åŒ…ï¼ˆchunksï¼‰ï¼ŒæŒ‰éœ€åŠ è½½ï¼Œä»è€Œå‡å°‘åˆå§‹åŠ è½½æ—¶é—´ï¼Œæå‡ç”¨æˆ·ä½“éªŒã€‚

ä»£ç åˆ†å‰²çš„æ ¸å¿ƒæ€æƒ³æ˜¯**"åªåŠ è½½å½“å‰éœ€è¦çš„ä»£ç "**ï¼Œé€šè¿‡å°†å¤§å‹åº”ç”¨æ‹†åˆ†æˆæ›´å°ã€æ›´æ˜“ç®¡ç†çš„ä»£ç å—ï¼Œå®ç°æ›´å¿«çš„é¡µé¢åŠ è½½é€Ÿåº¦å’Œæ›´å¥½çš„ç”¨æˆ·ä½“éªŒã€‚

### ğŸ¯ é€‚ç”¨åœºæ™¯

- **å¤§å‹å•é¡µåº”ç”¨ï¼ˆSPAï¼‰**ï¼šå‡å°‘é¦–å±åŠ è½½æ—¶é—´
- **å¤šé¡µé¢åº”ç”¨**ï¼šæŒ‰é¡µé¢åˆ†å‰²ä»£ç 
- **åŠŸèƒ½æ¨¡å—ä¸°å¯Œçš„åº”ç”¨**ï¼šæŒ‰åŠŸèƒ½æ¨¡å—åˆ†å‰²
- **ç¬¬ä¸‰æ–¹ä¾èµ–è¾ƒå¤šçš„é¡¹ç›®**ï¼šåˆ†ç¦» vendor ä»£ç 
- **ç§»åŠ¨ç«¯åº”ç”¨**ï¼šä¼˜åŒ–ç½‘ç»œèµ„æºæ¶ˆè€—

### æ ¸å¿ƒä¼˜åŠ¿
- **å‡å°‘åˆå§‹åŒ…å¤§å°**ï¼šåªåŠ è½½å¿…è¦çš„ä»£ç 
- **æå‡åŠ è½½é€Ÿåº¦**ï¼šå¹¶è¡ŒåŠ è½½å¤šä¸ªå°åŒ…
- **æ”¹å–„ç”¨æˆ·ä½“éªŒ**ï¼šæ›´å¿«çš„é¦–å±æ¸²æŸ“
- **ä¼˜åŒ–ç¼“å­˜ç­–ç•¥**ï¼šç‹¬ç«‹æ›´æ–°ä¸åŒæ¨¡å—
- **æŒ‰éœ€åŠ è½½**ï¼šç”¨æˆ·éœ€è¦æ—¶æ‰åŠ è½½ç›¸åº”åŠŸèƒ½

### åˆ†å‰²ç­–ç•¥
- **è·¯ç”±çº§åˆ†å‰²**ï¼šæŒ‰é¡µé¢/è·¯ç”±åˆ†å‰²ï¼Œé€‚ç”¨äº SPA åº”ç”¨
- **ç»„ä»¶çº§åˆ†å‰²**ï¼šæŒ‰ç»„ä»¶åˆ†å‰²ï¼Œé€‚ç”¨äºå¤§å‹ç»„ä»¶æˆ–æ¡ä»¶æ¸²æŸ“ç»„ä»¶
- **åŠŸèƒ½çº§åˆ†å‰²**ï¼šæŒ‰åŠŸèƒ½æ¨¡å—åˆ†å‰²ï¼Œé€‚ç”¨äºå¯é€‰åŠŸèƒ½æˆ–æƒé™ç›¸å…³åŠŸèƒ½
- **ç¬¬ä¸‰æ–¹åº“åˆ†å‰²**ï¼šåˆ†ç¦» vendor ä»£ç ï¼Œä¼˜åŒ–ç¼“å­˜ç­–ç•¥
- **å…¬å…±ä»£ç åˆ†å‰²**ï¼šæå–å…±äº«ä»£ç ï¼Œå‡å°‘é‡å¤æ‰“åŒ…
- **å¼‚æ­¥æ¨¡å—åˆ†å‰²**ï¼šæŒ‰éœ€åŠ è½½çš„å·¥å…·åº“å’Œæ’ä»¶
- **CSS ä»£ç åˆ†å‰²**ï¼šåˆ†ç¦»æ ·å¼æ–‡ä»¶ï¼Œä¼˜åŒ–å…³é”®æ¸²æŸ“è·¯å¾„

### ğŸ“Š æ€§èƒ½æŒ‡æ ‡

ä»£ç åˆ†å‰²çš„æ•ˆæœå¯ä»¥é€šè¿‡ä»¥ä¸‹æŒ‡æ ‡è¡¡é‡ï¼š

- **é¦–å±åŠ è½½æ—¶é—´ï¼ˆFCPï¼‰**ï¼šé¦–æ¬¡å†…å®¹ç»˜åˆ¶æ—¶é—´
- **æœ€å¤§å†…å®¹ç»˜åˆ¶ï¼ˆLCPï¼‰**ï¼šæœ€å¤§å†…å®¹å…ƒç´ çš„æ¸²æŸ“æ—¶é—´
- **é¦–æ¬¡è¾“å…¥å»¶è¿Ÿï¼ˆFIDï¼‰**ï¼šç”¨æˆ·é¦–æ¬¡äº¤äº’çš„å“åº”æ—¶é—´
- **ç´¯ç§¯å¸ƒå±€åç§»ï¼ˆCLSï¼‰**ï¼šé¡µé¢å¸ƒå±€ç¨³å®šæ€§
- **åŒ…å¤§å°å‡å°‘æ¯”ä¾‹**ï¼šåˆå§‹åŒ…å¤§å°çš„ä¼˜åŒ–ç¨‹åº¦
- **ç¼“å­˜å‘½ä¸­ç‡**ï¼šä»£ç å—çš„ç¼“å­˜åˆ©ç”¨ç‡

## Webpack ä»£ç åˆ†å‰²
### åŸºç¡€é…ç½®

```javascript
// webpack.config.js
const path = require('path')
const HtmlWebpackPlugin = require('html-webpack-plugin')
const { BundleAnalyzerPlugin } = require('webpack-bundle-analyzer')

module.exports = {
  mode: 'production',
  entry: {
    main: './src/index.js'
  },

  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: '[name].[contenthash].js',
    chunkFilename: '[name].[contenthash].chunk.js',
    clean: true
  },

  optimization: {
    // ä»£ç åˆ†å‰²é…ç½®
    splitChunks: {
      chunks: 'all',
      minSize: 20000,
      minRemainingSize: 0,
      minChunks: 1,
      maxAsyncRequests: 30,
      maxInitialRequests: 30,
      enforceSizeThreshold: 50000,

      cacheGroups: {
        // ç¬¬ä¸‰æ–¹åº“åˆ†å‰²
        vendor: {
          test: /[\\\/]node_modules[\\\/]/,
          name: 'vendors',
          priority: 10,
          chunks: 'all',
          enforce: true
        },

        // React ç›¸å…³åº“å•ç‹¬åˆ†å‰²
        react: {
          test: /[\\\/]node_modules[\\\/](react|react-dom)[\\\/]/,
          name: 'react',
          priority: 20,
          chunks: 'all',
          enforce: true
        },

        // UI åº“åˆ†å‰²
        ui: {
          test: /[\\\/]node_modules[\\\/](antd|@ant-design|element-ui)[\\\/]/,
          name: 'ui',
          priority: 15,
          chunks: 'all',
          enforce: true
        },

        // å·¥å…·åº“åˆ†å‰²
        utils: {
          test: /[\\\/]node_modules[\\\/](lodash|moment|dayjs|axios)[\\\/]/,
          name: 'utils',
          priority: 12,
          chunks: 'all',
          enforce: true
        },

        // å…¬å…±ä»£ç åˆ†å‰²
        common: {
          name: 'common',
          minChunks: 2,
          priority: 5,
          chunks: 'all',
          enforce: true
        },

        // é»˜è®¤åˆ†ç»„
        default: {
          minChunks: 2,
          priority: -10,
          reuseExistingChunk: true
        }
      }
    },

    // è¿è¡Œæ—¶ä»£ç åˆ†ç¦»
    runtimeChunk: {
      name: 'runtime'
    },

    // æ¨¡å— ID ä¼˜åŒ–
    moduleIds: 'deterministic',
    chunkIds: 'deterministic'
  },

  plugins: [
    new HtmlWebpackPlugin({
      template: './public/index.html',
      inject: true
    }),

    // åŒ…åˆ†æå·¥å…·
    new BundleAnalyzerPlugin({
      analyzerMode: process.env.ANALYZE ? 'server' : 'disabled',
      openAnalyzer: false
    })
  ]
}
```

### åŠ¨æ€å¯¼å…¥

```javascript
// åŠ¨æ€å¯¼å…¥å®ç°
class DynamicImporter {
  constructor() {
    this.cache = new Map()
    this.loading = new Map()
  }

  // åŸºç¡€åŠ¨æ€å¯¼å…¥
  async import(modulePath) {
    if (this.cache.has(modulePath)) {
      return this.cache.get(modulePath)
    }

    if (this.loading.has(modulePath)) {
      return this.loading.get(modulePath)
    }

    const promise = import(modulePath)
      .then(module => {
        this.cache.set(modulePath, module)
        this.loading.delete(modulePath)
        return module
      })
      .catch(error => {
        this.loading.delete(modulePath)
        throw error
      })

    this.loading.set(modulePath, promise)
    return promise
  }

  // é¢„åŠ è½½
  preload(modulePath) {
    if (!this.cache.has(modulePath) && !this.loading.has(modulePath)) {
      // ä½¿ç”¨ webpackPreload é­”æ³•æ³¨é‡Š
      import(/* webpackPreload: true */ modulePath)
        .then(module => {
          this.cache.set(modulePath, module)
        })
        .catch(error => {
          console.warn('Preload failed:', modulePath, error)
        })
    }
  }

  // é¢„è·å–
  prefetch(modulePath) {
    if (!this.cache.has(modulePath) && !this.loading.has(modulePath)) {
      // ä½¿ç”¨ webpackPrefetch é­”æ³•æ³¨é‡Š
      import(/* webpackPrefetch: true */ modulePath)
        .then(module => {
          this.cache.set(modulePath, module)
        })
        .catch(error => {
          console.warn('Prefetch failed:', modulePath, error)
        })
    }
  }

  // æ¡ä»¶åŠ è½½
  async conditionalImport(condition, modulePath) {
    if (condition) {
      return await this.import(modulePath)
    }
    return null
  }

  // æ‰¹é‡å¯¼å…¥
  async batchImport(modulePaths) {
    const promises = modulePaths.map(path => this.import(path))
    return await Promise.all(promises)
  }

  // é‡è¯•æœºåˆ¶
  async importWithRetry(modulePath, maxRetries = 3, delay = 1000) {
    let lastError

    for (let i = 0; i < maxRetries; i++) {
      try {
        return await this.import(modulePath)
      } catch (error) {
        lastError = error

        if (i < maxRetries - 1) {
          await new Promise(resolve => setTimeout(resolve, delay * (i + 1)))
        }
      }
    }

    throw lastError
  }

  // æ¸…ç†ç¼“å­˜
  clearCache(modulePath) {
    if (modulePath) {
      this.cache.delete(modulePath)
    } else {
      this.cache.clear()
    }
  }

  // è·å–ç¼“å­˜çŠ¶æ€
  getCacheInfo() {
    return {
      cached: Array.from(this.cache.keys()),
      loading: Array.from(this.loading.keys()),
      cacheSize: this.cache.size
    }
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const importer = new DynamicImporter()

// åŸºç¡€ä½¿ç”¨
async function loadComponent() {
  try {
    const module = await importer.import('./components/HeavyComponent')
    return module.default
  } catch (error) {
    console.error('Failed to load component:', error)
    return null
  }
}

// è·¯ç”±çº§ä»£ç åˆ†å‰²
const routes = [
  {
    path: '/home',
    component: () => importer.import('./pages/Home')
  },
  {
    path: '/dashboard',
    component: () => importer.import('./pages/Dashboard')
  },
  {
    path: '/profile',
    component: () => importer.import('./pages/Profile')
  }
]

// åŠŸèƒ½æ¨¡å—åˆ†å‰²
class FeatureLoader {
  static async loadChart() {
    const [chartModule, dataModule] = await importer.batchImport([
      /* webpackChunkName: "chart" */ './features/chart',
      /* webpackChunkName: "chart-data" */ './features/chart/data'
    ])

    return {
      Chart: chartModule.default,
      ChartData: dataModule.default
    }
  }

  static async loadEditor() {
    return await importer.importWithRetry(
      /* webpackChunkName: "editor" */ './features/editor'
    )
  }

  static async loadAnalytics() {
    // æ¡ä»¶åŠ è½½
    const hasPermission = await checkAnalyticsPermission()

    if (hasPermission) {
      return await importer.import(
        /* webpackChunkName: "analytics" */ './features/analytics'
      )
    }

    return null
  }
}
```

### Webpack é­”æ³•æ³¨é‡Š

```javascript
// Webpack é­”æ³•æ³¨é‡Šè¯¦è§£
class WebpackMagicComments {
  // 1. webpackChunkName - æŒ‡å®š chunk åç§°
  async loadNamedChunk() {
    const module = await import(
      /* webpackChunkName: "my-chunk-name" */ './module'
    )
    return module
  }

  // 2. webpackMode - æŒ‡å®šå¯¼å…¥æ¨¡å¼
  async loadWithMode() {
    // lazy: é»˜è®¤æ¨¡å¼ï¼Œç”Ÿæˆå¯å»¶è¿ŸåŠ è½½çš„ chunk
    const lazyModule = await import(
      /* webpackMode: "lazy" */ './lazy-module'
    )

    // eager: ä¸ç”Ÿæˆé¢å¤–çš„ chunkï¼Œç›´æ¥æ‰“åŒ…åˆ°å½“å‰ chunk
    const eagerModule = await import(
      /* webpackMode: "eager" */ './eager-module'
    )

    // weak: å¦‚æœæ¨¡å—å·²ç»åŠ è½½åˆ™ä½¿ç”¨ï¼Œå¦åˆ™å¤±è´¥
    const weakModule = await import(
      /* webpackMode: "weak" */ './weak-module'
    )

    return { lazyModule, eagerModule, weakModule }
  }

  // 3. webpackPrefetch - é¢„è·å–
  async setupPrefetch() {
    // åœ¨æµè§ˆå™¨ç©ºé—²æ—¶é¢„è·å–
    import(
      /* webpackPrefetch: true */
      /* webpackChunkName: "prefetch-module" */
      './prefetch-module'
    )
  }

  // 4. webpackPreload - é¢„åŠ è½½
  async setupPreload() {
    // ä¸çˆ¶ chunk å¹¶è¡ŒåŠ è½½
    import(
      /* webpackPreload: true */
      /* webpackChunkName: "preload-module" */
      './preload-module'
    )
  }

  // 5. webpackIgnore - å¿½ç•¥åŠ¨æ€å¯¼å…¥
  async loadIgnored() {
    const module = await import(
      /* webpackIgnore: true */ './ignored-module'
    )
    return module
  }

  // 6. webpackInclude/webpackExclude - åŒ…å«/æ’é™¤æ–‡ä»¶
  async loadWithFilter(moduleName) {
    const module = await import(
      /* webpackInclude: /\.json$/ */
      /* webpackExclude: /\.noimport\.json$/ */
      `./data/${moduleName}.json`
    )
    return module
  }

  // 7. ç»„åˆä½¿ç”¨
  async loadOptimized() {
    const module = await import(
      /* webpackChunkName: "optimized-chunk" */
      /* webpackMode: "lazy" */
      /* webpackPrefetch: true */
      './optimized-module'
    )
    return module
  }
}

// åŠ¨æ€å¯¼å…¥æ¨¡å¼ç¤ºä¾‹
class DynamicModuleLoader {
  constructor() {
    this.moduleCache = new Map()
  }

  // åŠ¨æ€æ¨¡å—åå¯¼å…¥
  async loadByName(moduleName) {
    try {
      const module = await import(
        /* webpackChunkName: "dynamic-[request]" */
        /* webpackMode: "lazy" */
        `./modules/${moduleName}`
      )
      return module.default
    } catch (error) {
      console.error(`Failed to load module: ${moduleName}`, error)
      return null
    }
  }

  // æ¡ä»¶åŠ¨æ€å¯¼å…¥
  async loadConditional(condition, truePath, falsePath) {
    const modulePath = condition ? truePath : falsePath

    return await import(
      /* webpackChunkName: "conditional-[request]" */
      modulePath
    )
  }

  // æ‰¹é‡åŠ¨æ€å¯¼å…¥
  async loadBatch(moduleNames) {
    const promises = moduleNames.map(name =>
      import(
        /* webpackChunkName: "batch-[request]" */
        `./modules/${name}`
      ).catch(error => {
        console.error(`Failed to load ${name}:`, error)
        return null
      })
    )

    return await Promise.all(promises)
  }
}
```

## React ä»£ç åˆ†å‰²
### React.lazy å’Œ Suspense

```jsx
// React ä»£ç åˆ†å‰²å®ç°
import React, { Suspense, lazy, useState, useEffect } from 'react'
import { BrowserRouter as Router, Routes, Route, Link } from 'react-router-dom'
import ErrorBoundary from './components/ErrorBoundary'
import LoadingSpinner from './components/LoadingSpinner'

// æ‡’åŠ è½½ç»„ä»¶
const Home = lazy(() => import('./pages/Home'))
const Dashboard = lazy(() => import('./pages/Dashboard'))
const Profile = lazy(() => import('./pages/Profile'))
const Settings = lazy(() => import('./pages/Settings'))

// å¸¦é”™è¯¯å¤„ç†çš„æ‡’åŠ è½½
const LazyChart = lazy(() =>
  import('./components/Chart')
    .catch(error => {
      console.error('Failed to load Chart component:', error)
      // è¿”å›é”™è¯¯ç»„ä»¶
      return { default: () => <div>Failed to load chart</div> }
    })
)

// æ¡ä»¶æ‡’åŠ è½½
const ConditionalComponent = lazy(() => {
  const userRole = getUserRole()

  if (userRole === 'admin') {
    return import('./components/AdminPanel')
  } else if (userRole === 'user') {
    return import('./components/UserPanel')
  } else {
    return import('./components/GuestPanel')
  }
})

// é«˜é˜¶ç»„ä»¶ï¼šæ‡’åŠ è½½åŒ…è£…å™¨
function withLazyLoading(importFunc, fallback = <LoadingSpinner />) {
  const LazyComponent = lazy(importFunc)

  return function WrappedComponent(props) {
    return (
      <ErrorBoundary>
        <Suspense fallback={fallback}>
          <LazyComponent {...props} />
        </Suspense>
      </ErrorBoundary>
    )
  }
}

// ä½¿ç”¨é«˜é˜¶ç»„ä»¶
const LazyDashboard = withLazyLoading(
  () => import('./pages/Dashboard'),
  <div>Loading Dashboard...</div>
)

// é¢„åŠ è½½ Hook
function usePreloadComponent(importFunc) {
  useEffect(() => {
    const preloadTimer = setTimeout(() => {
      importFunc()
    }, 2000) // 2ç§’åé¢„åŠ è½½

    return () => clearTimeout(preloadTimer)
  }, [])
}

// æ™ºèƒ½é¢„åŠ è½½ç»„ä»¶
function SmartPreloader({ children }) {
  const [isIdle, setIsIdle] = useState(false)

  useEffect(() => {
    // æ£€æµ‹æµè§ˆå™¨ç©ºé—²çŠ¶æ€
    if ('requestIdleCallback' in window) {
      const idleCallback = window.requestIdleCallback(() => {
        setIsIdle(true)
      })

      return () => window.cancelIdleCallback(idleCallback)
    } else {
      // é™çº§æ–¹æ¡ˆ
      const timer = setTimeout(() => setIsIdle(true), 3000)
      return () => clearTimeout(timer)
    }
  }, [])

  useEffect(() => {
    if (isIdle) {
      // é¢„åŠ è½½éå…³é”®ç»„ä»¶
      import('./components/NonCriticalComponent')
      import('./pages/SecondaryPage')
    }
  }, [isIdle])

  return children
}

// è·¯ç”±çº§ä»£ç åˆ†å‰²
function App() {
  // é¢„åŠ è½½å¸¸ç”¨é¡µé¢
  usePreloadComponent(() => import('./pages/Dashboard'))

  return (
    <Router>
      <SmartPreloader>
        <div className="app">
          <nav>
            <Link to="/">Home</Link>
            <Link to="/dashboard">Dashboard</Link>
            <Link to="/profile">Profile</Link>
            <Link to="/settings">Settings</Link>
          </nav>

          <main>
            <ErrorBoundary>
              <Suspense fallback={<LoadingSpinner />}>
                <Routes>
                  <Route path="/" element={<Home />} />
                  <Route path="/dashboard" element={<Dashboard />} />
                  <Route path="/profile" element={<Profile />} />
                  <Route path="/settings" element={<Settings />} />
                </Routes>
              </Suspense>
            </ErrorBoundary>
          </main>
        </div>
      </SmartPreloader>
    </Router>
  )
}

// ç»„ä»¶çº§ä»£ç åˆ†å‰²
function DashboardPage() {
  const [showChart, setShowChart] = useState(false)
  const [showTable, setShowTable] = useState(false)

  return (
    <div className="dashboard">
      <h1>Dashboard</h1>

      <div className="controls">
        <button onClick={() => setShowChart(!showChart)}>
          {showChart ? 'Hide' : 'Show'} Chart
        </button>
        <button onClick={() => setShowTable(!showTable)}>
          {showTable ? 'Hide' : 'Show'} Table
        </button>
      </div>

      {showChart && (
        <ErrorBoundary>
          <Suspense fallback={<div>Loading chart...</div>}>
            <LazyChart />
          </Suspense>
        </ErrorBoundary>
      )}

      {showTable && (
        <ErrorBoundary>
          <Suspense fallback={<div>Loading table...</div>}>
            <LazyTable />
          </Suspense>
        </ErrorBoundary>
      )}
    </div>
  )
}

// é”™è¯¯è¾¹ç•Œç»„ä»¶
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props)
    this.state = { hasError: false, error: null }
  }

  static getDerivedStateFromError(error) {
    return { hasError: true, error }
  }

  componentDidCatch(error, errorInfo) {
    console.error('Lazy loading error:', error, errorInfo)

    // å‘é€é”™è¯¯æŠ¥å‘Š
    this.reportError(error, errorInfo)
  }

  reportError(error, errorInfo) {
    // å‘é€åˆ°é”™è¯¯ç›‘æ§æœåŠ¡
    if (window.Sentry) {
      window.Sentry.captureException(error, {
        contexts: {
          react: {
            componentStack: errorInfo.componentStack
          }
        }
      })
    }
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="error-boundary">
          <h2>Something went wrong</h2>
          <p>Failed to load component. Please try refreshing the page.</p>
          <button onClick={() => window.location.reload()}>
            Refresh Page
          </button>
        </div>
      )
    }

    return this.props.children
  }
}

// åŠ è½½çŠ¶æ€ç»„ä»¶
function LoadingSpinner({ message = 'Loading...' }) {
  return (
    <div className="loading-spinner">
      <div className="spinner"></div>
      <p>{message}</p>
    </div>
  )
}

// æ¸è¿›å¼åŠ è½½ç»„ä»¶
function ProgressiveLoader({ children, fallback, delay = 200 }) {
  const [showFallback, setShowFallback] = useState(true)

  useEffect(() => {
    const timer = setTimeout(() => {
      setShowFallback(false)
    }, delay)

    return () => clearTimeout(timer)
  }, [])

  if (showFallback) {
    return fallback
  }

  return children
}
```

### React è·¯ç”±ä»£ç åˆ†å‰²

```jsx
// é«˜çº§è·¯ç”±ä»£ç åˆ†å‰²
import React, { Suspense, lazy } from 'react'
import { Routes, Route, Navigate } from 'react-router-dom'
import { useAuth } from './hooks/useAuth'
import LoadingPage from './components/LoadingPage'
import ErrorBoundary from './components/ErrorBoundary'

// è·¯ç”±é…ç½®
const routeConfig = [
  {
    path: '/',
    component: lazy(() => import('./pages/Home')),
    exact: true,
    public: true
  },
  {
    path: '/login',
    component: lazy(() => import('./pages/Login')),
    public: true
  },
  {
    path: '/dashboard',
    component: lazy(() => import('./pages/Dashboard')),
    private: true,
    preload: true
  },
  {
    path: '/profile',
    component: lazy(() => import('./pages/Profile')),
    private: true
  },
  {
    path: '/admin',
    component: lazy(() => import('./pages/Admin')),
    private: true,
    roles: ['admin']
  },
  {
    path: '/analytics',
    component: lazy(() =>
      import('./pages/Analytics').catch(() =>
        import('./pages/AnalyticsLite') // é™çº§ç»„ä»¶
      )
    ),
    private: true,
    roles: ['admin', 'analyst']
  }
]

// è·¯ç”±å®ˆå«ç»„ä»¶
function ProtectedRoute({ children, isPrivate, requiredRoles = [] }) {
  const { user, isAuthenticated, hasRole } = useAuth()

  if (isPrivate && !isAuthenticated) {
    return <Navigate to="/login" replace />
  }

  if (requiredRoles.length > 0 && !hasRole(requiredRoles)) {
    return <Navigate to="/unauthorized" replace />
  }

  return children
}

// æ™ºèƒ½è·¯ç”±ç»„ä»¶
function SmartRoute({ route }) {
  const { component: Component, preload, ...routeProps } = route

  // é¢„åŠ è½½é€»è¾‘
  React.useEffect(() => {
    if (preload) {
      // åœ¨ç»„ä»¶æŒ‚è½½åé¢„åŠ è½½
      const timer = setTimeout(() => {
        Component._payload._result || Component()
      }, 1000)

      return () => clearTimeout(timer)
    }
  }, [Component, preload])

  return (
    <Route
      {...routeProps}
      element={
        <ProtectedRoute
          isPrivate={route.private}
          requiredRoles={route.roles}
        >
          <ErrorBoundary>
            <Suspense fallback={<LoadingPage />}>
              <Component />
            </Suspense>
          </ErrorBoundary>
        </ProtectedRoute>
      }
    />
  )
}

// è·¯ç”±ç®¡ç†å™¨
function RouteManager() {
  const { isAuthenticated } = useAuth()

  // æ ¹æ®è®¤è¯çŠ¶æ€é¢„åŠ è½½è·¯ç”±
  React.useEffect(() => {
    if (isAuthenticated) {
      // é¢„åŠ è½½ç§æœ‰è·¯ç”±
      import('./pages/Dashboard')
      import('./pages/Profile')
    }
  }, [isAuthenticated])

  return (
    <Routes>
      {routeConfig.map((route, index) => (
        <SmartRoute key={index} route={route} />
      ))}

      {/* 404 é¡µé¢ */}
      <Route
        path="*"
        element={
          <Suspense fallback={<LoadingPage />}>
            <lazy(() => import('./pages/NotFound')) />
          </Suspense>
        }
      />
    </Routes>
  )
}

// è·¯ç”±é¢„åŠ è½½ Hook
function useRoutePreloader() {
  const [preloadedRoutes, setPreloadedRoutes] = React.useState(new Set())

  const preloadRoute = React.useCallback((routePath) => {
    if (preloadedRoutes.has(routePath)) {
      return
    }

    const route = routeConfig.find(r => r.path === routePath)

    if (route) {
      route.component()
      setPreloadedRoutes(prev => new Set([...prev, routePath]))
    }
  }, [preloadedRoutes])

  const preloadRoutes = React.useCallback((routePaths) => {
    routePaths.forEach(preloadRoute)
  }, [preloadRoute])

  return { preloadRoute, preloadRoutes, preloadedRoutes }
}

// ä½¿ç”¨ç¤ºä¾‹
function Navigation() {
  const { preloadRoute } = useRoutePreloader()

  return (
    <nav>
      <Link
        to="/dashboard"
        onMouseEnter={() => preloadRoute('/dashboard')}
      >
        Dashboard
      </Link>
      <Link
        to="/profile"
        onMouseEnter={() => preloadRoute('/profile')}
      >
        Profile
      </Link>
    </nav>
  )
}
```

## Vue ä»£ç åˆ†å‰²
### Vue 3 å¼‚æ­¥ç»„ä»¶

```vue
<!-- Vue 3 ä»£ç åˆ†å‰²å®ç° -->
<template>
  <div class="app">
    <nav>
      <router-link to="/">Home</router-link>
      <router-link to="/dashboard">Dashboard</router-link>
      <router-link to="/profile">Profile</router-link>
    </nav>

    <main>
      <router-view v-slot="{ Component }">
        <Suspense>
          <template #default>
            <component :is="Component" />
          </template>
          <template #fallback>
            <LoadingSpinner />
          </template>
        </Suspense>
      </router-view>
    </main>
  </div>
</template>

<script setup>
import { defineAsyncComponent, Suspense } from 'vue'
import LoadingSpinner from './components/LoadingSpinner.vue'

// å¼‚æ­¥ç»„ä»¶å®šä¹‰
const AsyncChart = defineAsyncComponent({
  loader: () => import('./components/Chart.vue'),
  loadingComponent: LoadingSpinner,
  errorComponent: () => import('./components/ErrorComponent.vue'),
  delay: 200,
  timeout: 3000,
  suspensible: false
})

// å¸¦é‡è¯•çš„å¼‚æ­¥ç»„ä»¶
const AsyncTableWithRetry = defineAsyncComponent({
  loader: () => {
    let retries = 0
    const maxRetries = 3

    const loadComponent = async () => {
      try {
        return await import('./components/DataTable.vue')
      } catch (error) {
        if (retries < maxRetries) {
          retries++
          console.log(`Retrying component load (${retries}/${maxRetries})`)
          await new Promise(resolve => setTimeout(resolve, 1000 * retries))
          return loadComponent()
        }
        throw error
      }
    }

    return loadComponent()
  },
  loadingComponent: LoadingSpinner,
  errorComponent: () => import('./components/ErrorComponent.vue')
})

// æ¡ä»¶å¼‚æ­¥ç»„ä»¶
const ConditionalComponent = defineAsyncComponent(() => {
  const userRole = getUserRole()

  switch (userRole) {
    case 'admin':
      return import('./components/AdminPanel.vue')
    case 'user':
      return import('./components/UserPanel.vue')
    default:
      return import('./components/GuestPanel.vue')
  }
})
</script>
```

```javascript
// Vue Router ä»£ç åˆ†å‰²
import { createRouter, createWebHistory } from 'vue-router'
import { defineAsyncComponent } from 'vue'

// è·¯ç”±çº§ä»£ç åˆ†å‰²
const routes = [
  {
    path: '/',
    name: 'Home',
    component: () => import('./views/Home.vue')
  },
  {
    path: '/dashboard',
    name: 'Dashboard',
    component: () => import(
      /* webpackChunkName: "dashboard" */
      './views/Dashboard.vue'
    ),
    meta: { preload: true }
  },
  {
    path: '/profile',
    name: 'Profile',
    component: () => import(
      /* webpackChunkName: "profile" */
      './views/Profile.vue'
    )
  },
  {
    path: '/admin',
    name: 'Admin',
    component: () => import(
      /* webpackChunkName: "admin" */
      './views/Admin.vue'
    ),
    meta: {
      requiresAuth: true,
      roles: ['admin']
    }
  }
]

const router = createRouter({
  history: createWebHistory(),
  routes
})

// è·¯ç”±é¢„åŠ è½½
router.beforeEach((to, from, next) => {
  // é¢„åŠ è½½ä¸‹ä¸€ä¸ªå¯èƒ½çš„è·¯ç”±
  if (to.meta.preload) {
    const nextRoutes = getNextPossibleRoutes(to.name)
    nextRoutes.forEach(route => {
      route.component()
    })
  }

  next()
})

// Vue ç»„åˆå¼ API ä»£ç åˆ†å‰²
import { ref, defineAsyncComponent, onMounted } from 'vue'

export default {
  setup() {
    const showChart = ref(false)
    const showTable = ref(false)

    // æ‡’åŠ è½½ç»„ä»¶
    const LazyChart = defineAsyncComponent(() =>
      import('./components/Chart.vue')
    )

    const LazyTable = defineAsyncComponent(() =>
      import('./components/DataTable.vue')
    )

    // é¢„åŠ è½½é€»è¾‘
    onMounted(() => {
      // å»¶è¿Ÿé¢„åŠ è½½éå…³é”®ç»„ä»¶
      setTimeout(() => {
        import('./components/NonCriticalComponent.vue')
      }, 2000)
    })

    return {
      showChart,
      showTable,
      LazyChart,
      LazyTable
    }
  }
}

// Vue 3 Composition API é¢„åŠ è½½ Hook
import { ref, onMounted, onUnmounted } from 'vue'

export function useComponentPreloader() {
  const preloadedComponents = ref(new Set())
  const preloadQueue = ref([])

  const preloadComponent = (importFunc, priority = 1) => {
    if (preloadedComponents.value.has(importFunc)) {
      return
    }

    preloadQueue.value.push({ importFunc, priority })
    preloadQueue.value.sort((a, b) => b.priority - a.priority)
  }

  const processPreloadQueue = async () => {
    while (preloadQueue.value.length > 0) {
      const { importFunc } = preloadQueue.value.shift()

      try {
        await importFunc()
        preloadedComponents.value.add(importFunc)
      } catch (error) {
        console.warn('Component preload failed:', error)
      }

      // é¿å…é˜»å¡ä¸»çº¿ç¨‹
      await new Promise(resolve => setTimeout(resolve, 100))
    }
  }

  onMounted(() => {
    // åœ¨ç©ºé—²æ—¶å¤„ç†é¢„åŠ è½½é˜Ÿåˆ—
    if ('requestIdleCallback' in window) {
      window.requestIdleCallback(processPreloadQueue)
    } else {
      setTimeout(processPreloadQueue, 1000)
    }
  })

  return {
    preloadComponent,
    preloadedComponents: preloadedComponents.value
  }
}
```

## ç°ä»£æ„å»ºå·¥å…·ä»£ç åˆ†å‰²
### Vite ä»£ç åˆ†å‰²

```javascript
// vite.config.js
import { defineConfig } from 'vite'
import { resolve } from 'path'

export default defineConfig({
  build: {
    rollupOptions: {
      input: {
        main: resolve(__dirname, 'index.html'),
        admin: resolve(__dirname, 'admin.html')
      },
      output: {
        // æ‰‹åŠ¨åˆ†å‰² chunks
        manualChunks: {
          // å°† React ç›¸å…³åº“æ‰“åŒ…åˆ°ä¸€ä¸ª chunk
          'react-vendor': ['react', 'react-dom'],
          // å°† UI åº“æ‰“åŒ…åˆ°ä¸€ä¸ª chunk
          'ui-vendor': ['antd', '@ant-design/icons'],
          // å°†å·¥å…·åº“æ‰“åŒ…åˆ°ä¸€ä¸ª chunk
          'utils-vendor': ['lodash-es', 'dayjs', 'axios']
        },
        // æˆ–è€…ä½¿ç”¨å‡½æ•°å½¢å¼è¿›è¡Œæ›´ç²¾ç»†çš„æ§åˆ¶
        manualChunks(id) {
          // å°† node_modules ä¸­çš„åŒ…åˆ†ç¦»
          if (id.includes('node_modules')) {
            // React ç”Ÿæ€
            if (id.includes('react') || id.includes('react-dom')) {
              return 'react-vendor'
            }
            // UI ç»„ä»¶åº“
            if (id.includes('antd') || id.includes('@ant-design')) {
              return 'ui-vendor'
            }
            // å›¾è¡¨åº“
            if (id.includes('echarts') || id.includes('chart.js')) {
              return 'chart-vendor'
            }
            // å…¶ä»–ç¬¬ä¸‰æ–¹åº“
            return 'vendor'
          }
          
          // å°†ç‰¹å®šç›®å½•çš„æ–‡ä»¶åˆ†ç¦»
          if (id.includes('/src/utils/')) {
            return 'utils'
          }
          
          if (id.includes('/src/components/')) {
            return 'components'
          }
        }
      }
    },
    
    // ä»£ç åˆ†å‰²é˜ˆå€¼
    chunkSizeWarningLimit: 1000,
    
    // å¯ç”¨ CSS ä»£ç åˆ†å‰²
    cssCodeSplit: true
  },
  
  // é¢„æ„å»ºä¼˜åŒ–
  optimizeDeps: {
    include: ['react', 'react-dom', 'antd'],
    exclude: ['@vite/client', '@vite/env']
  }
})

// åŠ¨æ€å¯¼å…¥ç¤ºä¾‹
class ViteDynamicImporter {
  constructor() {
    this.moduleCache = new Map()
  }

  // Vite æ”¯æŒçš„åŠ¨æ€å¯¼å…¥
  async importModule(modulePath) {
    if (this.moduleCache.has(modulePath)) {
      return this.moduleCache.get(modulePath)
    }

    try {
      const module = await import(/* @vite-ignore */ modulePath)
      this.moduleCache.set(modulePath, module)
      return module
    } catch (error) {
      console.error(`Failed to import module: ${modulePath}`, error)
      throw error
    }
  }

  // é¢„åŠ è½½æ¨¡å—
  preloadModule(modulePath) {
    // Vite ä¼šè‡ªåŠ¨å¤„ç†é¢„åŠ è½½
    import(modulePath).catch(error => {
      console.warn(`Preload failed: ${modulePath}`, error)
    })
  }

  // æ¡ä»¶å¯¼å…¥
  async conditionalImport(condition, modulePath) {
    if (condition) {
      return await this.importModule(modulePath)
    }
    return null
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const importer = new ViteDynamicImporter()

// è·¯ç”±çº§ä»£ç åˆ†å‰²
const routes = [
  {
    path: '/dashboard',
    component: () => importer.importModule('./pages/Dashboard.vue')
  },
  {
    path: '/profile',
    component: () => importer.importModule('./pages/Profile.vue')
  }
]
```

### Rollup ä»£ç åˆ†å‰²

```javascript
// rollup.config.js
import { defineConfig } from 'rollup'
import resolve from '@rollup/plugin-node-resolve'
import commonjs from '@rollup/plugin-commonjs'
import { terser } from 'rollup-plugin-terser'
import analyze from 'rollup-plugin-analyzer'

export default defineConfig({
  input: {
    main: 'src/main.js',
    admin: 'src/admin.js'
  },
  
  output: {
    dir: 'dist',
    format: 'es',
    entryFileNames: '[name].[hash].js',
    chunkFileNames: '[name].[hash].chunk.js',
    
    // æ‰‹åŠ¨åˆ†å‰²
    manualChunks: {
      'vendor': ['react', 'react-dom'],
      'ui': ['antd'],
      'utils': ['lodash-es', 'dayjs']
    }
  },
  
  plugins: [
    resolve({
      browser: true,
      preferBuiltins: false
    }),
    commonjs(),
    terser({
      compress: {
        drop_console: true,
        drop_debugger: true
      }
    }),
    analyze({
      summaryOnly: true,
      limit: 10
    })
  ],
  
  // å¤–éƒ¨ä¾èµ–
  external: ['react', 'react-dom'],
  
  // ä»£ç åˆ†å‰²ä¼˜åŒ–
  experimentalCodeSplitting: true
})

// Rollup åŠ¨æ€å¯¼å…¥å·¥å…·
class RollupChunkLoader {
  constructor() {
    this.loadedChunks = new Set()
    this.loadingPromises = new Map()
  }

  async loadChunk(chunkName) {
    if (this.loadedChunks.has(chunkName)) {
      return
    }

    if (this.loadingPromises.has(chunkName)) {
      return this.loadingPromises.get(chunkName)
    }

    const loadPromise = this.doLoadChunk(chunkName)
    this.loadingPromises.set(chunkName, loadPromise)

    try {
      await loadPromise
      this.loadedChunks.add(chunkName)
    } finally {
      this.loadingPromises.delete(chunkName)
    }
  }

  async doLoadChunk(chunkName) {
    const script = document.createElement('script')
    script.src = `/dist/${chunkName}.chunk.js`
    script.type = 'module'

    return new Promise((resolve, reject) => {
      script.onload = resolve
      script.onerror = reject
      document.head.appendChild(script)
    })
  }

  preloadChunks(chunkNames) {
    chunkNames.forEach(chunkName => {
      const link = document.createElement('link')
      link.rel = 'modulepreload'
      link.href = `/dist/${chunkName}.chunk.js`
      document.head.appendChild(link)
    })
  }
}
```

### Parcel ä»£ç åˆ†å‰²

```javascript
// Parcel è‡ªåŠ¨ä»£ç åˆ†å‰²
// .parcelrc
{
  "extends": "@parcel/config-default",
  "optimizers": {
    "*.js": ["@parcel/optimizer-terser"]
  },
  "bundler": "@parcel/bundler-default"
}

// package.json
{
  "scripts": {
    "build": "parcel build src/index.html --dist-dir dist",
    "dev": "parcel src/index.html --dist-dir dev"
  },
  "targets": {
    "default": {
      "distDir": "dist",
      "optimize": true
    }
  }
}

// Parcel åŠ¨æ€å¯¼å…¥
class ParcelDynamicLoader {
  constructor() {
    this.cache = new Map()
  }

  // Parcel æ”¯æŒçš„åŠ¨æ€å¯¼å…¥è¯­æ³•
  async loadModule(modulePath) {
    if (this.cache.has(modulePath)) {
      return this.cache.get(modulePath)
    }

    try {
      // Parcel ä¼šè‡ªåŠ¨å¤„ç†ä»£ç åˆ†å‰²
      const module = await import(modulePath)
      this.cache.set(modulePath, module)
      return module
    } catch (error) {
      console.error(`Failed to load module: ${modulePath}`, error)
      throw error
    }
  }

  // é¢„åŠ è½½èµ„æº
  preloadAsset(assetPath) {
    const link = document.createElement('link')
    link.rel = 'preload'
    link.href = assetPath
    link.as = 'script'
    document.head.appendChild(link)
  }

  // æ‰¹é‡é¢„åŠ è½½
  preloadModules(modulePaths) {
    modulePaths.forEach(path => {
      import(path).catch(error => {
        console.warn(`Preload failed: ${path}`, error)
      })
    })
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const loader = new ParcelDynamicLoader()

// æ¡ä»¶åŠ è½½
async function loadFeature(featureName) {
  switch (featureName) {
    case 'chart':
      return await loader.loadModule('./features/chart')
    case 'editor':
      return await loader.loadModule('./features/editor')
    case 'analytics':
      return await loader.loadModule('./features/analytics')
    default:
      throw new Error(`Unknown feature: ${featureName}`)
  }
}
```

## ç¬¬ä¸‰æ–¹åº“åˆ†å‰²
### Vendor åˆ†ç¦»ç­–ç•¥

```javascript
// vendor åˆ†ç¦»é…ç½®
const path = require('path')

module.exports = {
  optimization: {
    splitChunks: {
      chunks: 'all',
      cacheGroups: {
        // åŸºç¡€æ¡†æ¶åº“
        framework: {
          test: /[\\\/]node_modules[\\\/](react|react-dom|vue|@vue)[\\\/]/,
          name: 'framework',
          priority: 40,
          chunks: 'all',
          enforce: true
        },

        // UI ç»„ä»¶åº“
        ui: {
          test: /[\\\/]node_modules[\\\/](antd|@ant-design|element-ui|element-plus|vuetify)[\\\/]/,
          name: 'ui',
          priority: 30,
          chunks: 'all',
          enforce: true
        },

        // å›¾è¡¨åº“
        charts: {
          test: /[\\\/]node_modules[\\\/](echarts|chart\.js|d3|@nivo)[\\\/]/,
          name: 'charts',
          priority: 25,
          chunks: 'all',
          enforce: true
        },

        // å·¥å…·åº“
        utils: {
          test: /[\\\/]node_modules[\\\/](lodash|moment|dayjs|date-fns|ramda)[\\\/]/,
          name: 'utils',
          priority: 20,
          chunks: 'all',
          enforce: true
        },

        // HTTP åº“
        http: {
          test: /[\\\/]node_modules[\\\/](axios|fetch|superagent)[\\\/]/,
          name: 'http',
          priority: 18,
          chunks: 'all',
          enforce: true
        },

        // çŠ¶æ€ç®¡ç†
        state: {
          test: /[\\\/]node_modules[\\\/](redux|@reduxjs|vuex|pinia|mobx)[\\\/]/,
          name: 'state',
          priority: 15,
          chunks: 'all',
          enforce: true
        },

        // å…¶ä»–ç¬¬ä¸‰æ–¹åº“
        vendor: {
          test: /[\\\/]node_modules[\\\/]/,
          name: 'vendor',
          priority: 10,
          chunks: 'all',
          enforce: true,
          minSize: 30000
        },

        // å…¬å…±ä»£ç 
        common: {
          name: 'common',
          minChunks: 2,
          priority: 5,
          chunks: 'all',
          enforce: true
        }
      }
    }
  }
}

// åŠ¨æ€ vendor åˆ†å‰²
class DynamicVendorSplitter {
  constructor() {
    this.vendorGroups = new Map()
    this.loadedVendors = new Set()
  }

  // æ³¨å†Œ vendor ç»„
  registerVendorGroup(name, packages, priority = 10) {
    this.vendorGroups.set(name, {
      packages,
      priority,
      loaded: false
    })
  }

  // åŠ¨æ€åŠ è½½ vendor
  async loadVendor(vendorName) {
    if (this.loadedVendors.has(vendorName)) {
      return
    }

    const vendorGroup = this.vendorGroups.get(vendorName)

    if (!vendorGroup) {
      throw new Error(`Vendor group '${vendorName}' not found`)
    }

    try {
      // åŠ¨æ€å¯¼å…¥ vendor åŒ…
      const modules = await Promise.all(
        vendorGroup.packages.map(pkg =>
          import(/* webpackChunkName: "vendor-[request]" */ pkg)
        )
      )

      this.loadedVendors.add(vendorName)
      vendorGroup.loaded = true

      return modules
    } catch (error) {
      console.error(`Failed to load vendor '${vendorName}':`, error)
      throw error
    }
  }

  // é¢„åŠ è½½å…³é”® vendor
  async preloadCriticalVendors() {
    const criticalVendors = Array.from(this.vendorGroups.entries())
      .filter(([, group]) => group.priority >= 20)
      .sort((a, b) => b[1].priority - a[1].priority)

    for (const [name] of criticalVendors) {
      try {
        await this.loadVendor(name)
      } catch (error) {
        console.warn(`Failed to preload critical vendor '${name}':`, error)
      }
    }
  }

  // è·å–åŠ è½½çŠ¶æ€
  getLoadStatus() {
    const status = {}

    for (const [name, group] of this.vendorGroups) {
      status[name] = {
        loaded: group.loaded,
        priority: group.priority,
        packages: group.packages
      }
    }

    return status
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const vendorSplitter = new DynamicVendorSplitter()

// æ³¨å†Œ vendor ç»„
vendorSplitter.registerVendorGroup('charts', [
  'echarts',
  'chart.js',
  'd3'
], 25)

vendorSplitter.registerVendorGroup('ui', [
  'antd',
  '@ant-design/icons'
], 30)

vendorSplitter.registerVendorGroup('utils', [
  'lodash',
  'moment',
  'axios'
], 20)

// æ¡ä»¶åŠ è½½ vendor
async function loadChartingCapability() {
  try {
    const chartModules = await vendorSplitter.loadVendor('charts')
    console.log('Charting libraries loaded:', chartModules)
  } catch (error) {
    console.error('Failed to load charting capability:', error)
  }
}

// åº”ç”¨å¯åŠ¨æ—¶é¢„åŠ è½½å…³é”® vendor
vendorSplitter.preloadCriticalVendors()
```

### Tree Shaking ä¼˜åŒ–

```javascript
// Tree Shaking é…ç½®
module.exports = {
  mode: 'production',

  optimization: {
    usedExports: true,
    sideEffects: false, // æˆ–è€…æŒ‡å®šå…·ä½“æ–‡ä»¶

    // è‡ªå®šä¹‰ Tree Shaking
    innerGraph: true,
    providedExports: true,

    // Terser é…ç½®
    minimizer: [
      new TerserPlugin({
        terserOptions: {
          compress: {
            drop_console: true,
            drop_debugger: true,
            pure_funcs: ['console.log', 'console.info'],
            unused: true,
            dead_code: true
          },
          mangle: {
            safari10: true
          }
        }
      })
    ]
  },

  // æ¨¡å—è§£æé…ç½®
  resolve: {
    mainFields: ['es2015', 'module', 'main'],
    alias: {
      // ä½¿ç”¨ ES æ¨¡å—ç‰ˆæœ¬
      'lodash': 'lodash-es',
      'moment': 'dayjs'
    }
  },

  module: {
    rules: [
      {
        test: /\.js$/,
        exclude: /node_modules/,
        use: {
          loader: 'babel-loader',
          options: {
            presets: [
              ['@babel/preset-env', {
                modules: false, // ä¿æŒ ES æ¨¡å—
                useBuiltIns: 'usage',
                corejs: 3
              }]
            ]
          }
        }
      }
    ]
  }
}

// æŒ‰éœ€å¯¼å…¥å·¥å…·
class SelectiveImporter {
  constructor() {
    this.importMap = new Map()
  }

  // æ³¨å†ŒæŒ‰éœ€å¯¼å…¥é…ç½®
  register(libraryName, config) {
    this.importMap.set(libraryName, config)
  }

  // ç”ŸæˆæŒ‰éœ€å¯¼å…¥ä»£ç 
  generateImport(libraryName, methods) {
    const config = this.importMap.get(libraryName)

    if (!config) {
      throw new Error(`Library '${libraryName}' not configured`)
    }

    const imports = methods.map(method => {
      if (config.type === 'named') {
        return `import { ${method} } from '${libraryName}'`
      } else if (config.type === 'default') {
        return `import ${method} from '${libraryName}/${config.path || ''}${method}'`
      }
    })

    return imports.join('\n')
  }
}

// é…ç½®å¸¸ç”¨åº“çš„æŒ‰éœ€å¯¼å…¥
const importer = new SelectiveImporter()

importer.register('lodash', {
  type: 'default',
  path: ''
})

importer.register('antd', {
  type: 'named',
  styleImport: true
})

// ä½¿ç”¨ç¤ºä¾‹
console.log(importer.generateImport('lodash', ['debounce', 'throttle']))
// è¾“å‡º:
// import debounce from 'lodash/debounce'
// import throttle from 'lodash/throttle'

// Babel æ’ä»¶ï¼šè‡ªåŠ¨æŒ‰éœ€å¯¼å…¥
function babelPluginImportOnDemand() {
  return {
    visitor: {
      ImportDeclaration(path) {
        const source = path.node.source.value

        // è½¬æ¢ lodash å¯¼å…¥
        if (source === 'lodash') {
          const specifiers = path.node.specifiers

          const newImports = specifiers.map(spec => {
            if (spec.type === 'ImportSpecifier') {
              return `import ${spec.local.name} from 'lodash/${spec.imported.name}'`
            }
          })

          // æ›¿æ¢åŸå¯¼å…¥
          path.replaceWithMultiple(
            newImports.map(imp =>
              require('@babel/parser').parse(imp, { sourceType: 'module' }).body[0]
            )
          )
        }
      }
    }
  }
}
```

## æ€§èƒ½ç›‘æ§
### åˆ†å‰²æ•ˆæœåˆ†æ

```javascript
// ä»£ç åˆ†å‰²æ€§èƒ½ç›‘æ§
class CodeSplittingAnalyzer {
  constructor() {
    this.metrics = {
      chunks: new Map(),
      loadTimes: new Map(),
      errors: new Map(),
      cacheHits: new Map()
    }

    this.observer = null
    this.setupPerformanceObserver()
  }

  setupPerformanceObserver() {
    if ('PerformanceObserver' in window) {
      this.observer = new PerformanceObserver((list) => {
        for (const entry of list.getEntries()) {
          if (entry.entryType === 'resource' && entry.name.includes('.chunk.js')) {
            this.recordChunkLoad(entry)
          }
        }
      })

      this.observer.observe({ entryTypes: ['resource'] })
    }
  }

  recordChunkLoad(entry) {
    const chunkName = this.extractChunkName(entry.name)
    const loadTime = entry.responseEnd - entry.startTime
    const fromCache = entry.transferSize === 0

    // è®°å½•åŠ è½½æ—¶é—´
    if (!this.metrics.loadTimes.has(chunkName)) {
      this.metrics.loadTimes.set(chunkName, [])
    }
    this.metrics.loadTimes.get(chunkName).push(loadTime)

    // è®°å½•ç¼“å­˜å‘½ä¸­
    if (!this.metrics.cacheHits.has(chunkName)) {
      this.metrics.cacheHits.set(chunkName, { hits: 0, total: 0 })
    }

    const cacheStats = this.metrics.cacheHits.get(chunkName)
    cacheStats.total++
    if (fromCache) {
      cacheStats.hits++
    }

    // è®°å½• chunk ä¿¡æ¯
    this.metrics.chunks.set(chunkName, {
      size: entry.transferSize,
      loadTime,
      fromCache,
      timestamp: Date.now()
    })
  }

  recordChunkError(chunkName, error) {
    if (!this.metrics.errors.has(chunkName)) {
      this.metrics.errors.set(chunkName, []
    }

    this.metrics.errors.get(chunkName).push({
      error: error.message,
      timestamp: Date.now()
    })
  }

  extractChunkName(url) {
    const match = url.match(/([^/]+)\.chunk\.js$/)
    return match ? match[1] : 'unknown'
  }

  getAnalytics() {
    const analytics = {
      totalChunks: this.metrics.chunks.size,
      averageLoadTime: 0,
      cacheHitRate: 0,
      errorRate: 0,
      chunkDetails: []
    }

    let totalLoadTime = 0
    let totalRequests = 0
    let totalCacheHits = 0
    let totalErrors = 0

    for (const [chunkName, loadTimes] of this.metrics.loadTimes) {
      const avgLoadTime = loadTimes.reduce((a, b) => a + b, 0) / loadTimes.length
      const cacheStats = this.metrics.cacheHits.get(chunkName) || { hits: 0, total: 0 }
      const errors = this.metrics.errors.get(chunkName) || []

      analytics.chunkDetails.push({
        name: chunkName,
        averageLoadTime: avgLoadTime,
        requests: loadTimes.length,
        cacheHitRate: cacheStats.total > 0 ? (cacheStats.hits / cacheStats.total * 100) : 0,
        errors: errors.length
      })

      totalLoadTime += avgLoadTime * loadTimes.length
      totalRequests += loadTimes.length
      totalCacheHits += cacheStats.hits
      totalErrors += errors.length
    }

    analytics.averageLoadTime = totalRequests > 0 ? totalLoadTime / totalRequests : 0
    analytics.cacheHitRate = totalRequests > 0 ? (totalCacheHits / totalRequests * 100) : 0
    analytics.errorRate = totalRequests > 0 ? (totalErrors / totalRequests * 100) : 0

    return analytics
  }

  generateReport() {
    const analytics = this.getAnalytics()

    return {
      summary: {
        totalChunks: analytics.totalChunks,
        averageLoadTime: `${analytics.averageLoadTime.toFixed(2)}ms`,
        cacheHitRate: `${analytics.cacheHitRate.toFixed(2)}%`,
        errorRate: `${analytics.errorRate.toFixed(2)}%`
      },
      recommendations: this.generateRecommendations(analytics),
      chunkDetails: analytics.chunkDetails
    }
  }

  generateRecommendations(analytics) {
    const recommendations = []

    if (analytics.averageLoadTime > 1000) {
      recommendations.push('Consider further splitting large chunks')
    }

    if (analytics.cacheHitRate < 50) {
      recommendations.push('Improve caching strategy for better performance')
    }

    if (analytics.errorRate > 5) {
      recommendations.push('Investigate and fix chunk loading errors')
    }

    const largeChunks = analytics.chunkDetails.filter(chunk =>
      chunk.averageLoadTime > 2000
    )

    if (largeChunks.length > 0) {
      recommendations.push(`Consider splitting these large chunks: ${largeChunks.map(c => c.name).join(', ')}`)
    }

    return recommendations
  }

  cleanup() {
    if (this.observer) {
      this.observer.disconnect()
    }
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const analyzer = new CodeSplittingAnalyzer()

// å®šæœŸç”ŸæˆæŠ¥å‘Š
setInterval(() => {
  const report = analyzer.generateReport()
  console.log('Code Splitting Report:', report)

  // å‘é€åˆ°åˆ†ææœåŠ¡
  if (window.analytics) {
    window.analytics.track('code_splitting_metrics', report)
  }
}, 60000) // æ¯åˆ†é’Ÿç”Ÿæˆä¸€æ¬¡æŠ¥å‘Š

// é¡µé¢å¸è½½æ—¶æ¸…ç†
window.addEventListener('beforeunload', () => {
  analyzer.cleanup()
})
```

### Bundle åˆ†æå·¥å…·

```javascript
// Bundle åˆ†æå™¨
class BundleAnalyzer {
  constructor() {
    this.bundleInfo = null
    this.loadBundleInfo()
  }

  async loadBundleInfo() {
    try {
      // ä» webpack-bundle-analyzer ç”Ÿæˆçš„æ•°æ®åŠ è½½
      const response = await fetch('/bundle-stats.json')
      this.bundleInfo = await response.json()
    } catch (error) {
      console.warn('Bundle info not available:', error)
    }
  }

  analyzeBundleSize() {
    if (!this.bundleInfo) {
      return null
    }

    const analysis = {
      totalSize: 0,
      gzippedSize: 0,
      chunks: [],
      duplicates: [],
      recommendations: []
    }

    // åˆ†ææ¯ä¸ª chunk
    for (const chunk of this.bundleInfo.chunks) {
      analysis.totalSize += chunk.size
      analysis.gzippedSize += chunk.gzippedSize || chunk.size * 0.3

      analysis.chunks.push({
        name: chunk.name,
        size: chunk.size,
        modules: chunk.modules.length,
        isInitial: chunk.initial,
        isAsync: !chunk.initial
      })
    }

    // æ£€æµ‹é‡å¤æ¨¡å—
    const moduleMap = new Map()

    for (const chunk of this.bundleInfo.chunks) {
      for (const module of chunk.modules) {
        if (!moduleMap.has(module.name)) {
          moduleMap.set(module.name, [])
        }
        moduleMap.get(module.name).push(chunk.name)
      }
    }

    for (const [moduleName, chunks] of moduleMap) {
      if (chunks.length > 1) {
        analysis.duplicates.push({
          module: moduleName,
          chunks: chunks,
          occurrences: chunks.length
        })
      }
    }

    // ç”Ÿæˆå»ºè®®
    analysis.recommendations = this.generateBundleRecommendations(analysis)

    return analysis
  }

  generateBundleRecommendations(analysis) {
    const recommendations = []

    // æ£€æŸ¥å¤§å‹ chunk
    const largeChunks = analysis.chunks.filter(chunk => chunk.size > 500000) // 500KB
    if (largeChunks.length > 0) {
      recommendations.push({
        type: 'large_chunks',
        message: `Consider splitting these large chunks: ${largeChunks.map(c => c.name).join(', ')}`,
        chunks: largeChunks
      })
    }

    // æ£€æŸ¥é‡å¤æ¨¡å—
    const significantDuplicates = analysis.duplicates.filter(dup => dup.occurrences > 2)
    if (significantDuplicates.length > 0) {
      recommendations.push({
        type: 'duplicate_modules',
        message: 'Extract common modules to reduce duplication',
        duplicates: significantDuplicates
      })
    }

    // æ£€æŸ¥åˆå§‹åŒ…å¤§å°
    const initialChunks = analysis.chunks.filter(chunk => chunk.isInitial)
    const initialSize = initialChunks.reduce((sum, chunk) => sum + chunk.size, 0)

    if (initialSize > 1000000) { // 1MB
      recommendations.push({
        type: 'large_initial_bundle',
        message: 'Initial bundle size is too large, consider lazy loading more components',
        size: initialSize
      })
    }

    return recommendations
  }

  generateOptimizationPlan() {
    const analysis = this.analyzeBundleSize()

    if (!analysis) {
      return null
    }

    const plan = {
      priority: 'high',
      actions: [],
      expectedSavings: 0
    }

    // åŸºäºåˆ†æç»“æœç”Ÿæˆä¼˜åŒ–è®¡åˆ’
    for (const recommendation of analysis.recommendations) {
      switch (recommendation.type) {
        case 'large_chunks':
          plan.actions.push({
            action: 'split_chunks',
            description: 'Split large chunks into smaller ones',
            chunks: recommendation.chunks,
            estimatedSaving: recommendation.chunks.reduce((sum, chunk) => sum + chunk.size * 0.3, 0)
          })
          break

        case 'duplicate_modules':
          plan.actions.push({
            action: 'extract_common',
            description: 'Extract common modules to separate chunk',
            modules: recommendation.duplicates,
            estimatedSaving: recommendation.duplicates.length * 50000 // ä¼°ç®—
          })
          break

        case 'large_initial_bundle':
          plan.actions.push({
            action: 'lazy_load',
            description: 'Implement lazy loading for non-critical components',
            currentSize: recommendation.size,
            estimatedSaving: recommendation.size * 0.4
          })
          break
      }
    }

    plan.expectedSavings = plan.actions.reduce((sum, action) => sum + action.estimatedSaving, 0)

    return plan
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const bundleAnalyzer = new BundleAnalyzer()

// åˆ†æå½“å‰ bundle
setTimeout(async () => {
  const analysis = bundleAnalyzer.analyzeBundleSize()
  const optimizationPlan = bundleAnalyzer.generateOptimizationPlan()

  console.log('Bundle Analysis:', analysis)
  console.log('Optimization Plan:', optimizationPlan)
}, 5000)
```

## æœ€ä½³å®è·µ
### åˆ†å‰²ç­–ç•¥é€‰æ‹©

1. **è·¯ç”±çº§åˆ†å‰²**
   - é€‚ç”¨äº SPA åº”ç”¨
   - æŒ‰é¡µé¢åŠŸèƒ½åˆ†å‰²
   - æå‡é¦–å±åŠ è½½é€Ÿåº¦

2. **ç»„ä»¶çº§åˆ†å‰²**
   - å¤§å‹ç»„ä»¶ç‹¬ç«‹åˆ†å‰²
   - æ¡ä»¶æ¸²æŸ“ç»„ä»¶
   - ç”¨æˆ·äº¤äº’è§¦å‘çš„ç»„ä»¶

3. **åŠŸèƒ½æ¨¡å—åˆ†å‰²**
   - æŒ‰ä¸šåŠ¡åŠŸèƒ½åˆ†å‰²
   - æƒé™ç›¸å…³åŠŸèƒ½
   - å¯é€‰åŠŸèƒ½æ¨¡å—

4. **ç¬¬ä¸‰æ–¹åº“åˆ†å‰²**
   - æ¡†æ¶åº“å•ç‹¬åˆ†å‰²
   - UI åº“ç‹¬ç«‹æ‰“åŒ…
   - å·¥å…·åº“æŒ‰éœ€åŠ è½½

### æ€§èƒ½ä¼˜åŒ–æŠ€å·§

```javascript
// æ€§èƒ½ä¼˜åŒ–æœ€ä½³å®è·µ
class CodeSplittingOptimizer {
  constructor() {
    this.preloadQueue = []
    this.prefetchQueue = []
    this.loadedChunks = new Set()
  }

  // æ™ºèƒ½é¢„åŠ è½½
  smartPreload(routes, userBehavior) {
    // åŸºäºç”¨æˆ·è¡Œä¸ºé¢„æµ‹ä¸‹ä¸€ä¸ªå¯èƒ½è®¿é—®çš„è·¯ç”±
    const predictedRoutes = this.predictNextRoutes(userBehavior)

    predictedRoutes.forEach(route => {
      if (!this.loadedChunks.has(route)) {
        this.preloadQueue.push(route)
      }
    })

    this.processPreloadQueue()
  }

  predictNextRoutes(userBehavior) {
    // ç®€å•çš„é¢„æµ‹ç®—æ³•
    const { currentRoute, visitHistory, timeSpent } = userBehavior

    // åŸºäºè®¿é—®å†å²é¢„æµ‹
    const frequentRoutes = this.getFrequentRoutes(visitHistory)

    // åŸºäºåœç•™æ—¶é—´é¢„æµ‹
    if (timeSpent > 30000) { // 30ç§’ä»¥ä¸Š
      return frequentRoutes.slice(0, 2)
    }

    return frequentRoutes.slice(0, 1)
  }

  getFrequentRoutes(visitHistory) {
    const routeCount = {}

    visitHistory.forEach(route => {
      routeCount[route] = (routeCount[route] || 0) + 1
    })

    return Object.entries(routeCount)
      .sort(([,a], [,b]) => b - a)
      .map(([route]) => route)
  }

  async processPreloadQueue() {
    while (this.preloadQueue.length > 0) {
      const route = this.preloadQueue.shift()

      try {
        await this.preloadRoute(route)
        this.loadedChunks.add(route)
      } catch (error) {
        console.warn(`Failed to preload route ${route}:`, error)
      }

      // é¿å…é˜»å¡ä¸»çº¿ç¨‹
      await new Promise(resolve => setTimeout(resolve, 100))
    }
  }

  async preloadRoute(route) {
    // ä½¿ç”¨ link rel="preload" é¢„åŠ è½½
    const link = document.createElement('link')
    link.rel = 'preload'
    link.as = 'script'
    link.href = this.getChunkUrl(route)

    document.head.appendChild(link)

    return new Promise((resolve, reject) => {
      link.onload = resolve
      link.onerror = reject
    })
  }

  getChunkUrl(route) {
    // æ ¹æ®è·¯ç”±è·å–å¯¹åº”çš„ chunk URL
    const chunkMap = {
      '/dashboard': '/static/js/dashboard.chunk.js',
      '/profile': '/static/js/profile.chunk.js',
      '/settings': '/static/js/settings.chunk.js'
    }

    return chunkMap[route] || ''
  }
}
```

### é”™è¯¯å¤„ç†ç­–ç•¥

```javascript
// ä»£ç åˆ†å‰²é”™è¯¯å¤„ç†
class ChunkLoadErrorHandler {
  constructor() {
    this.retryCount = new Map()
    this.maxRetries = 3
    this.retryDelay = 1000
  }

  async handleChunkLoadError(chunkName, importFunc) {
    const currentRetries = this.retryCount.get(chunkName) || 0

    if (currentRetries >= this.maxRetries) {
      throw new Error(`Failed to load chunk ${chunkName} after ${this.maxRetries} retries`)
    }

    // å¢åŠ é‡è¯•æ¬¡æ•°
    this.retryCount.set(chunkName, currentRetries + 1)

    // å»¶è¿Ÿé‡è¯•
    await new Promise(resolve =>
      setTimeout(resolve, this.retryDelay * (currentRetries + 1))
    )

    try {
      const result = await importFunc()
      // é‡ç½®é‡è¯•æ¬¡æ•°
      this.retryCount.delete(chunkName)
      return result
    } catch (error) {
      return this.handleChunkLoadError(chunkName, importFunc)
    }
  }

  // é™çº§å¤„ç†
  async loadWithFallback(primaryImport, fallbackImport) {
    try {
      return await primaryImport()
    } catch (error) {
      console.warn('Primary chunk load failed, using fallback:', error)
      return await fallbackImport()
    }
  }

  // ç½‘ç»œçŠ¶æ€æ£€æµ‹
  isNetworkSlow() {
    if ('connection' in navigator) {
      const connection = navigator.connection
      return connection.effectiveType === 'slow-2g' ||
             connection.effectiveType === '2g'
    }
    return false
  }

  // è‡ªé€‚åº”åŠ è½½ç­–ç•¥
  async adaptiveLoad(chunkImports) {
    if (this.isNetworkSlow()) {
      // ç½‘ç»œæ…¢æ—¶åªåŠ è½½å…³é”® chunk
      const criticalChunks = chunkImports.filter(chunk => chunk.critical)
      return await Promise.all(criticalChunks.map(chunk => chunk.import()))
    } else {
      // ç½‘ç»œå¿«æ—¶åŠ è½½æ‰€æœ‰ chunk
      return await Promise.all(chunkImports.map(chunk => chunk.import()))
    }
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const errorHandler = new ChunkLoadErrorHandler()

// å¸¦é‡è¯•çš„ç»„ä»¶åŠ è½½
const LazyComponentWithRetry = lazy(() =>
  errorHandler.handleChunkLoadError(
    'heavy-component',
    () => import('./components/HeavyComponent')
  )
)

// å¸¦é™çº§çš„ç»„ä»¶åŠ è½½
const LazyComponentWithFallback = lazy(() =>
  errorHandler.loadWithFallback(
    () => import('./components/AdvancedComponent'),
    () => import('./components/BasicComponent')
  )
)
```

## CSS ä»£ç åˆ†å‰²
### CSS-in-JS ä»£ç åˆ†å‰²

```javascript
// styled-components ä»£ç åˆ†å‰²
import styled, { css } from 'styled-components'
import { lazy, Suspense } from 'react'

// æ‡’åŠ è½½æ ·å¼ç»„ä»¶
const LazyStyledComponent = lazy(() =>
  import('./StyledComponents').then(module => ({
    default: module.HeavyStyledComponent
  }))
)

// æ¡ä»¶æ ·å¼åŠ è½½
const ConditionalStyles = styled.div`
  ${props => props.theme === 'dark' && css`
    /* åªåœ¨éœ€è¦æ—¶åŠ è½½æ·±è‰²ä¸»é¢˜æ ·å¼ */
    background: #333;
    color: #fff;
  `}
  
  ${props => props.variant === 'premium' && css`
    /* åªåœ¨é«˜çº§ç‰ˆæœ¬æ—¶åŠ è½½ */
    background: linear-gradient(45deg, #gold, #orange);
  `}
`

// åŠ¨æ€ä¸»é¢˜åŠ è½½
class ThemeLoader {
  constructor() {
    this.loadedThemes = new Set()
    this.themeCache = new Map()
  }

  async loadTheme(themeName) {
    if (this.loadedThemes.has(themeName)) {
      return this.themeCache.get(themeName)
    }

    try {
      const themeModule = await import(`./themes/${themeName}.js`)
      const theme = themeModule.default
      
      this.themeCache.set(themeName, theme)
      this.loadedThemes.add(themeName)
      
      return theme
    } catch (error) {
      console.error(`Failed to load theme: ${themeName}`, error)
      // è¿”å›é»˜è®¤ä¸»é¢˜
      return await this.loadTheme('default')
    }
  }

  async switchTheme(themeName) {
    const theme = await this.loadTheme(themeName)
    
    // åº”ç”¨ä¸»é¢˜
    document.documentElement.style.setProperty('--primary-color', theme.primaryColor)
    document.documentElement.style.setProperty('--background-color', theme.backgroundColor)
    
    return theme
  }
}
```

### CSS æ¨¡å—ä»£ç åˆ†å‰²

```javascript
// CSS æ¨¡å—æ‡’åŠ è½½
class CSSModuleLoader {
  constructor() {
    this.loadedModules = new Set()
    this.styleElements = new Map()
  }

  async loadCSSModule(moduleName) {
    if (this.loadedModules.has(moduleName)) {
      return
    }

    try {
      // åŠ¨æ€å¯¼å…¥ CSS æ¨¡å—
      const cssModule = await import(`./styles/${moduleName}.module.css`)
      
      // åˆ›å»º style å…ƒç´ 
      const styleElement = document.createElement('style')
      styleElement.textContent = cssModule.default
      styleElement.setAttribute('data-module', moduleName)
      
      document.head.appendChild(styleElement)
      
      this.styleElements.set(moduleName, styleElement)
      this.loadedModules.add(moduleName)
      
      return cssModule
    } catch (error) {
      console.error(`Failed to load CSS module: ${moduleName}`, error)
    }
  }

  unloadCSSModule(moduleName) {
    const styleElement = this.styleElements.get(moduleName)
    
    if (styleElement) {
      document.head.removeChild(styleElement)
      this.styleElements.delete(moduleName)
      this.loadedModules.delete(moduleName)
    }
  }

  // æ¡ä»¶åŠ è½½æ ·å¼
  async loadConditionalStyles(condition, moduleName) {
    if (condition) {
      await this.loadCSSModule(moduleName)
    } else {
      this.unloadCSSModule(moduleName)
    }
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const cssLoader = new CSSModuleLoader()

// æ ¹æ®è®¾å¤‡ç±»å‹åŠ è½½ä¸åŒæ ·å¼
const isMobile = window.innerWidth < 768
if (isMobile) {
  cssLoader.loadCSSModule('mobile')
} else {
  cssLoader.loadCSSModule('desktop')
}

// æ ¹æ®åŠŸèƒ½åŠ è½½æ ·å¼
async function enableDarkMode() {
  await cssLoader.loadCSSModule('dark-theme')
  document.body.classList.add('dark-mode')
}

async function enableAnimations() {
  await cssLoader.loadCSSModule('animations')
  document.body.classList.add('animations-enabled')
}
```

## å¾®å‰ç«¯ä»£ç åˆ†å‰²
### Module Federation

```javascript
// webpack.config.js - ä¸»åº”ç”¨
const ModuleFederationPlugin = require('@module-federation/webpack')

module.exports = {
  mode: 'development',
  devServer: {
    port: 3000
  },
  plugins: [
    new ModuleFederationPlugin({
      name: 'shell',
      remotes: {
        // è¿œç¨‹å¾®å‰ç«¯åº”ç”¨
        dashboard: 'dashboard@http://localhost:3001/remoteEntry.js',
        profile: 'profile@http://localhost:3002/remoteEntry.js',
        analytics: 'analytics@http://localhost:3003/remoteEntry.js'
      },
      shared: {
        react: { singleton: true },
        'react-dom': { singleton: true }
      }
    })
  ]
}

// å¾®å‰ç«¯åŠ¨æ€åŠ è½½å™¨
class MicrofrontendLoader {
  constructor() {
    this.loadedApps = new Map()
    this.loadingPromises = new Map()
  }

  async loadMicrofrontend(appName, remoteName) {
    if (this.loadedApps.has(appName)) {
      return this.loadedApps.get(appName)
    }

    if (this.loadingPromises.has(appName)) {
      return this.loadingPromises.get(appName)
    }

    const loadPromise = this.doLoadMicrofrontend(appName, remoteName)
    this.loadingPromises.set(appName, loadPromise)

    try {
      const app = await loadPromise
      this.loadedApps.set(appName, app)
      return app
    } finally {
      this.loadingPromises.delete(appName)
    }
  }

  async doLoadMicrofrontend(appName, remoteName) {
    try {
      // åŠ¨æ€å¯¼å…¥è¿œç¨‹æ¨¡å—
      const container = await import(remoteName)
      await container.init(__webpack_share_scopes__.default)
      
      const factory = await container.get('./App')
      const Module = factory()
      
      return Module.default || Module
    } catch (error) {
      console.error(`Failed to load microfrontend: ${appName}`, error)
      
      // è¿”å›é”™è¯¯ç»„ä»¶
      return () => React.createElement('div', null, `Failed to load ${appName}`)
    }
  }

  // é¢„åŠ è½½å¾®å‰ç«¯
  preloadMicrofrontends(apps) {
    apps.forEach(({ appName, remoteName }) => {
      this.loadMicrofrontend(appName, remoteName).catch(error => {
        console.warn(`Preload failed for ${appName}:`, error)
      })
    })
  }

  // å¸è½½å¾®å‰ç«¯
  unloadMicrofrontend(appName) {
    this.loadedApps.delete(appName)
    
    // æ¸…ç†ç›¸å…³èµ„æº
    const scripts = document.querySelectorAll(`script[src*="${appName}"]`)
    scripts.forEach(script => script.remove())
  }
}

// React ç»„ä»¶ä¸­ä½¿ç”¨
import React, { Suspense, lazy } from 'react'

const microfrontendLoader = new MicrofrontendLoader()

// æ‡’åŠ è½½å¾®å‰ç«¯ç»„ä»¶
const DashboardApp = lazy(() =>
  microfrontendLoader.loadMicrofrontend('dashboard', 'dashboard/App')
)

const ProfileApp = lazy(() =>
  microfrontendLoader.loadMicrofrontend('profile', 'profile/App')
)

function App() {
  return (
    <Router>
      <Routes>
        <Route
          path="/dashboard/*"
          element={
            <Suspense fallback={<div>Loading Dashboard...</div>}>
              <DashboardApp />
            </Suspense>
          }
        />
        <Route
          path="/profile/*"
          element={
            <Suspense fallback={<div>Loading Profile...</div>}>
              <ProfileApp />
            </Suspense>
          }
        />
      </Routes>
    </Router>
  )
}
```

### Single-SPA ä»£ç åˆ†å‰²

```javascript
// single-spa é…ç½®
import { registerApplication, start } from 'single-spa'

// åŠ¨æ€æ³¨å†Œå¾®å‰ç«¯åº”ç”¨
class SingleSPALoader {
  constructor() {
    this.registeredApps = new Set()
  }

  registerApp(appName, loadingFunction, activityFunction) {
    if (this.registeredApps.has(appName)) {
      return
    }

    registerApplication({
      name: appName,
      app: loadingFunction,
      activeWhen: activityFunction,
      customProps: {
        domElement: document.getElementById(`${appName}-container`)
      }
    })

    this.registeredApps.add(appName)
  }

  // æ¡ä»¶æ³¨å†Œåº”ç”¨
  conditionalRegister(condition, appName, loadingFunction, activityFunction) {
    if (condition) {
      this.registerApp(appName, loadingFunction, activityFunction)
    }
  }

  // æ‰¹é‡æ³¨å†Œ
  registerApps(apps) {
    apps.forEach(({ name, loader, activity, condition = true }) => {
      this.conditionalRegister(condition, name, loader, activity)
    })
  }
}

const spaLoader = new SingleSPALoader()

// æ³¨å†Œå¾®å‰ç«¯åº”ç”¨
spaLoader.registerApps([
  {
    name: 'dashboard',
    loader: () => import('./microfrontends/dashboard'),
    activity: location => location.pathname.startsWith('/dashboard')
  },
  {
    name: 'profile',
    loader: () => import('./microfrontends/profile'),
    activity: location => location.pathname.startsWith('/profile'),
    condition: userHasPermission('profile')
  },
  {
    name: 'admin',
    loader: () => import('./microfrontends/admin'),
    activity: location => location.pathname.startsWith('/admin'),
    condition: userIsAdmin()
  }
])

// å¯åŠ¨ single-spa
start()
```

## å®é™…åº”ç”¨æ¡ˆä¾‹
### ç”µå•†å¹³å°ä»£ç åˆ†å‰²

```javascript
// ç”µå•†å¹³å°ä»£ç åˆ†å‰²ç­–ç•¥
class EcommerceCodeSplitting {
  constructor() {
    this.userRole = this.getUserRole()
    this.deviceType = this.getDeviceType()
    this.setupCodeSplitting()
  }

  setupCodeSplitting() {
    // åŸºç¡€é¡µé¢åˆ†å‰²
    this.setupBasicPages()
    
    // ç”¨æˆ·è§’è‰²ç›¸å…³åˆ†å‰²
    this.setupRoleBasedSplitting()
    
    // è®¾å¤‡ç±»å‹åˆ†å‰²
    this.setupDeviceBasedSplitting()
    
    // åŠŸèƒ½æ¨¡å—åˆ†å‰²
    this.setupFeatureBasedSplitting()
  }

  setupBasicPages() {
    // é¦–é¡µ - ç«‹å³åŠ è½½
    const HomePage = lazy(() => import('./pages/Home'))
    
    // å•†å“åˆ—è¡¨ - é¢„åŠ è½½
    const ProductList = lazy(() => import('./pages/ProductList'))
    
    // å•†å“è¯¦æƒ… - æŒ‰éœ€åŠ è½½
    const ProductDetail = lazy(() => import('./pages/ProductDetail'))
    
    // è´­ç‰©è½¦ - ç”¨æˆ·äº¤äº’æ—¶åŠ è½½
    const ShoppingCart = lazy(() => import('./pages/ShoppingCart'))
    
    // ç»“ç®—é¡µé¢ - ç”¨æˆ·ç‚¹å‡»ç»“ç®—æ—¶åŠ è½½
    const Checkout = lazy(() => import('./pages/Checkout'))
    
    return {
      HomePage,
      ProductList,
      ProductDetail,
      ShoppingCart,
      Checkout
    }
  }

  setupRoleBasedSplitting() {
    const components = {}
    
    // æ™®é€šç”¨æˆ·ç»„ä»¶
    if (this.userRole === 'customer') {
      components.UserProfile = lazy(() => import('./components/UserProfile'))
      components.OrderHistory = lazy(() => import('./components/OrderHistory'))
    }
    
    // å•†å®¶ç»„ä»¶
    if (this.userRole === 'seller') {
      components.SellerDashboard = lazy(() => import('./components/SellerDashboard'))
      components.ProductManagement = lazy(() => import('./components/ProductManagement'))
      components.OrderManagement = lazy(() => import('./components/OrderManagement'))
    }
    
    // ç®¡ç†å‘˜ç»„ä»¶
    if (this.userRole === 'admin') {
      components.AdminPanel = lazy(() => import('./components/AdminPanel'))
      components.UserManagement = lazy(() => import('./components/UserManagement'))
      components.SystemSettings = lazy(() => import('./components/SystemSettings'))
    }
    
    return components
  }

  setupDeviceBasedSplitting() {
    if (this.deviceType === 'mobile') {
      // ç§»åŠ¨ç«¯ç‰¹å®šç»„ä»¶
      return {
        MobileNavigation: lazy(() => import('./components/mobile/Navigation')),
        MobileProductCard: lazy(() => import('./components/mobile/ProductCard')),
        MobileCheckout: lazy(() => import('./components/mobile/Checkout'))
      }
    } else {
      // æ¡Œé¢ç«¯ç‰¹å®šç»„ä»¶
      return {
        DesktopNavigation: lazy(() => import('./components/desktop/Navigation')),
        DesktopProductCard: lazy(() => import('./components/desktop/ProductCard')),
        DesktopCheckout: lazy(() => import('./components/desktop/Checkout'))
      }
    }
  }

  setupFeatureBasedSplitting() {
    return {
      // æœç´¢åŠŸèƒ½
      SearchModule: lazy(() => import('./features/search')),
      
      // æ¨èç³»ç»Ÿ
      RecommendationEngine: lazy(() => import('./features/recommendation')),
      
      // æ”¯ä»˜æ¨¡å—
      PaymentModule: lazy(() => import('./features/payment')),
      
      // ç‰©æµè·Ÿè¸ª
      ShippingTracker: lazy(() => import('./features/shipping')),
      
      // å®¢æœèŠå¤©
      CustomerService: lazy(() => import('./features/chat')),
      
      // æ•°æ®åˆ†æ
      Analytics: lazy(() => import('./features/analytics'))
    }
  }

  // æ™ºèƒ½é¢„åŠ è½½
  async smartPreload() {
    const userBehavior = await this.getUserBehavior()
    
    // åŸºäºç”¨æˆ·è¡Œä¸ºé¢„åŠ è½½
    if (userBehavior.frequentlyViewsProducts) {
      import('./pages/ProductDetail')
    }
    
    if (userBehavior.hasItemsInCart) {
      import('./pages/ShoppingCart')
      import('./features/payment')
    }
    
    if (userBehavior.isReturningCustomer) {
      import('./components/UserProfile')
      import('./components/OrderHistory')
    }
  }

  getUserRole() {
    // è·å–ç”¨æˆ·è§’è‰²é€»è¾‘
    return localStorage.getItem('userRole') || 'guest'
  }

  getDeviceType() {
    return window.innerWidth < 768 ? 'mobile' : 'desktop'
  }

  async getUserBehavior() {
    // åˆ†æç”¨æˆ·è¡Œä¸ºæ•°æ®
    return {
      frequentlyViewsProducts: true,
      hasItemsInCart: localStorage.getItem('cartItems') !== null,
      isReturningCustomer: localStorage.getItem('userId') !== null
    }
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const ecommerceSplitting = new EcommerceCodeSplitting()
ecommerceSplitting.smartPreload()
```

## æ•…éšœæ’é™¤
### å¸¸è§é—®é¢˜

1. **Chunk åŠ è½½å¤±è´¥**
   ```javascript
   // è§£å†³æ–¹æ¡ˆï¼šæ·»åŠ é‡è¯•æœºåˆ¶
   const retryImport = (importFunc, retries = 3) => {
     return importFunc().catch(error => {
       if (retries > 0) {
         return new Promise(resolve => {
           setTimeout(() => resolve(retryImport(importFunc, retries - 1)), 1000)
         })
       }
       throw error
     })
   }
   ```

2. **ç¼“å­˜é—®é¢˜**
   ```javascript
   // è§£å†³æ–¹æ¡ˆï¼šä½¿ç”¨ contenthash
   output: {
     filename: '[name].[contenthash].js',
     chunkFilename: '[name].[contenthash].chunk.js'
   }
   ```

3. **é¢„åŠ è½½è¿‡å¤š**
   ```javascript
   // è§£å†³æ–¹æ¡ˆï¼šæ™ºèƒ½é¢„åŠ è½½
   const shouldPreload = (route) => {
     const userBehavior = getUserBehavior()
     return userBehavior.likelyToVisit.includes(route)
   }
   ```

### è°ƒè¯•å·¥å…·

```javascript
// ä»£ç åˆ†å‰²è°ƒè¯•å·¥å…·
class CodeSplittingDebugger {
  constructor() {
    this.enabled = process.env.NODE_ENV === 'development'
    this.logs = []
  }

  log(message, data = {}) {
    if (!this.enabled) return

    const logEntry = {
      timestamp: Date.now(),
      message,
      data
    }

    this.logs.push(logEntry)
    console.log(`[CodeSplitting] ${message}`, data)
  }

  trackChunkLoad(chunkName, startTime) {
    const loadTime = Date.now() - startTime
    this.log(`Chunk loaded: ${chunkName}`, { loadTime })
  }

  trackChunkError(chunkName, error) {
    this.log(`Chunk error: ${chunkName}`, { error: error.message })
  }

  generateReport() {
    return {
      totalLogs: this.logs.length,
      errors: this.logs.filter(log => log.message.includes('error')),
      loadTimes: this.logs
        .filter(log => log.message.includes('loaded'))
        .map(log => log.data.loadTime)
    }
  }
}

const debugger = new CodeSplittingDebugger()

// åœ¨åŠ¨æ€å¯¼å…¥ä¸­ä½¿ç”¨
const loadChunkWithDebug = async (chunkName, importFunc) => {
  const startTime = Date.now()

  try {
    const result = await importFunc()
    debugger.trackChunkLoad(chunkName, startTime)
    return result
  } catch (error) {
    debugger.trackChunkError(chunkName, error)
    throw error
  }
}
```

## é«˜çº§æ€§èƒ½ä¼˜åŒ–
### æ™ºèƒ½é¢„åŠ è½½ç­–ç•¥

```javascript
// æ™ºèƒ½é¢„åŠ è½½ç®¡ç†å™¨
class IntelligentPreloader {
  constructor() {
    this.preloadQueue = new Set()
    this.loadedModules = new Set()
    this.userBehaviorData = new Map()
    this.networkCondition = this.getNetworkCondition()
    this.deviceCapabilities = this.getDeviceCapabilities()
    
    this.setupIntersectionObserver()
    this.setupUserBehaviorTracking()
  }

  // åŸºäºç”¨æˆ·è¡Œä¸ºçš„é¢„æµ‹æ€§é¢„åŠ è½½
  async predictivePreload() {
    const predictions = await this.analyzeUserBehavior()
    
    predictions.forEach(({ module, probability, priority }) => {
      if (probability > 0.7 && this.shouldPreload(priority)) {
        this.schedulePreload(module, priority)
      }
    })
  }

  // åŸºäºè§†å£çš„æ™ºèƒ½é¢„åŠ è½½
  setupIntersectionObserver() {
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const preloadTarget = entry.target.dataset.preload
            if (preloadTarget) {
              this.schedulePreload(preloadTarget, 'high')
            }
          }
        })
      },
      {
        rootMargin: '50px 0px',
        threshold: 0.1
      }
    )

    // è§‚å¯Ÿæ‰€æœ‰å¸¦æœ‰ data-preload å±æ€§çš„å…ƒç´ 
    document.querySelectorAll('[data-preload]').forEach(el => {
      observer.observe(el)
    })
  }

  // ç”¨æˆ·è¡Œä¸ºè·Ÿè¸ª
  setupUserBehaviorTracking() {
    // é¼ æ ‡æ‚¬åœé¢„åŠ è½½
    document.addEventListener('mouseover', (e) => {
      const link = e.target.closest('[data-hover-preload]')
      if (link) {
        const module = link.dataset.hoverPreload
        this.schedulePreload(module, 'medium', 200) // 200ms å»¶è¿Ÿ
      }
    })

    // ç‚¹å‡»æ„å›¾æ£€æµ‹
    document.addEventListener('mousedown', (e) => {
      const link = e.target.closest('[data-click-preload]')
      if (link) {
        const module = link.dataset.clickPreload
        this.schedulePreload(module, 'urgent')
      }
    })

    // æ»šåŠ¨è¡Œä¸ºåˆ†æ
    let scrollTimeout
    document.addEventListener('scroll', () => {
      clearTimeout(scrollTimeout)
      scrollTimeout = setTimeout(() => {
        this.analyzeScrollBehavior()
      }, 150)
    })
  }

  // ç½‘ç»œæ¡ä»¶é€‚åº”æ€§é¢„åŠ è½½
  shouldPreload(priority) {
    const { effectiveType, downlink } = this.networkCondition
    
    // æ ¹æ®ç½‘ç»œæ¡ä»¶è°ƒæ•´é¢„åŠ è½½ç­–ç•¥
    if (effectiveType === '4g' && downlink > 2) {
      return true // è‰¯å¥½ç½‘ç»œï¼Œç§¯æé¢„åŠ è½½
    } else if (effectiveType === '3g' && priority === 'high') {
      return true // ä¸­ç­‰ç½‘ç»œï¼Œåªé¢„åŠ è½½é«˜ä¼˜å…ˆçº§
    } else if (effectiveType === '2g' && priority === 'urgent') {
      return true // æ…¢ç½‘ç»œï¼Œåªé¢„åŠ è½½ç´§æ€¥å†…å®¹
    }
    
    return false
  }

  // è®¾å¤‡èƒ½åŠ›é€‚åº”æ€§
  getDeviceCapabilities() {
    return {
      memory: navigator.deviceMemory || 4,
      cores: navigator.hardwareConcurrency || 4,
      isMobile: /Mobi|Android/i.test(navigator.userAgent)
    }
  }

  // è°ƒåº¦é¢„åŠ è½½
  async schedulePreload(module, priority, delay = 0) {
    if (this.loadedModules.has(module) || this.preloadQueue.has(module)) {
      return
    }

    this.preloadQueue.add(module)

    // æ ¹æ®ä¼˜å…ˆçº§å’Œè®¾å¤‡èƒ½åŠ›è°ƒæ•´å»¶è¿Ÿ
    const adjustedDelay = this.calculateDelay(delay, priority)

    setTimeout(async () => {
      try {
        await this.preloadModule(module)
        this.loadedModules.add(module)
        this.preloadQueue.delete(module)
      } catch (error) {
        console.warn(`Preload failed for ${module}:`, error)
        this.preloadQueue.delete(module)
      }
    }, adjustedDelay)
  }

  async preloadModule(module) {
    // ä½¿ç”¨ link rel="modulepreload" è¿›è¡Œé¢„åŠ è½½
    const link = document.createElement('link')
    link.rel = 'modulepreload'
    link.href = module
    document.head.appendChild(link)

    // åŒæ—¶è¿›è¡ŒåŠ¨æ€å¯¼å…¥é¢„åŠ è½½
    return import(module)
  }

  calculateDelay(baseDelay, priority) {
    const priorityMultipliers = {
      urgent: 0,
      high: 0.5,
      medium: 1,
      low: 2
    }

    const deviceMultiplier = this.deviceCapabilities.isMobile ? 1.5 : 1
    const networkMultiplier = this.networkCondition.effectiveType === '2g' ? 3 : 1

    return baseDelay * priorityMultipliers[priority] * deviceMultiplier * networkMultiplier
  }

  getNetworkCondition() {
    const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection
    
    return {
      effectiveType: connection?.effectiveType || '4g',
      downlink: connection?.downlink || 10,
      rtt: connection?.rtt || 100
    }
  }

  async analyzeUserBehavior() {
    // åˆ†æç”¨æˆ·è¡Œä¸ºæ¨¡å¼ï¼Œè¿”å›é¢„æµ‹ç»“æœ
    const currentPath = window.location.pathname
    const timeOnPage = Date.now() - this.pageStartTime
    const scrollDepth = this.getScrollDepth()

    // åŸºäºå†å²æ•°æ®é¢„æµ‹ç”¨æˆ·ä¸‹ä¸€æ­¥è¡Œä¸º
    return [
      { module: './pages/ProductDetail', probability: 0.8, priority: 'high' },
      { module: './components/ShoppingCart', probability: 0.6, priority: 'medium' },
      { module: './features/search', probability: 0.4, priority: 'low' }
    ]
  }

  getScrollDepth() {
    const scrollTop = window.pageYOffset || document.documentElement.scrollTop
    const documentHeight = document.documentElement.scrollHeight - window.innerHeight
    return Math.round((scrollTop / documentHeight) * 100)
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const preloader = new IntelligentPreloader()
preloader.predictivePreload()
```

### å†…å­˜ç®¡ç†ä¼˜åŒ–

```javascript
// å†…å­˜ç®¡ç†å™¨
class MemoryManager {
  constructor() {
    this.moduleCache = new Map()
    this.memoryThreshold = this.calculateMemoryThreshold()
    this.cleanupInterval = 30000 // 30ç§’æ¸…ç†ä¸€æ¬¡
    
    this.startMemoryMonitoring()
  }

  calculateMemoryThreshold() {
    const deviceMemory = navigator.deviceMemory || 4
    // æ ¹æ®è®¾å¤‡å†…å­˜è®¾ç½®é˜ˆå€¼ï¼ˆMBï¼‰
    return deviceMemory >= 8 ? 100 : deviceMemory >= 4 ? 50 : 25
  }

  startMemoryMonitoring() {
    setInterval(() => {
      this.checkMemoryUsage()
    }, this.cleanupInterval)

    // ç›‘å¬å†…å­˜å‹åŠ›äº‹ä»¶
    if ('memory' in performance) {
      setInterval(() => {
        const memInfo = performance.memory
        const usedMB = memInfo.usedJSHeapSize / 1024 / 1024
        
        if (usedMB > this.memoryThreshold) {
          this.aggressiveCleanup()
        }
      }, 5000)
    }
  }

  async checkMemoryUsage() {
    if ('memory' in performance) {
      const memInfo = performance.memory
      const usedMB = memInfo.usedJSHeapSize / 1024 / 1024
      const totalMB = memInfo.totalJSHeapSize / 1024 / 1024
      
      console.log(`Memory usage: ${usedMB.toFixed(2)}MB / ${totalMB.toFixed(2)}MB`)
      
      if (usedMB > this.memoryThreshold * 0.8) {
        await this.performCleanup()
      }
    }
  }

  async performCleanup() {
    // æ¸…ç†æœªä½¿ç”¨çš„æ¨¡å—
    const unusedModules = this.findUnusedModules()
    
    for (const moduleId of unusedModules) {
      await this.unloadModule(moduleId)
    }

    // å¼ºåˆ¶åƒåœ¾å›æ”¶ï¼ˆå¦‚æœå¯ç”¨ï¼‰
    if (window.gc) {
      window.gc()
    }
  }

  findUnusedModules() {
    const currentTime = Date.now()
    const unusedThreshold = 5 * 60 * 1000 // 5åˆ†é’Ÿæœªä½¿ç”¨
    
    return Array.from(this.moduleCache.entries())
      .filter(([id, info]) => {
        return currentTime - info.lastUsed > unusedThreshold && !info.isPersistent
      })
      .map(([id]) => id)
  }

  async unloadModule(moduleId) {
    const moduleInfo = this.moduleCache.get(moduleId)
    
    if (moduleInfo && moduleInfo.cleanup) {
      try {
        await moduleInfo.cleanup()
      } catch (error) {
        console.warn(`Cleanup failed for module ${moduleId}:`, error)
      }
    }

    this.moduleCache.delete(moduleId)
    
    // ç§»é™¤ç›¸å…³çš„ DOM å…ƒç´ 
    const elements = document.querySelectorAll(`[data-module="${moduleId}"]`)
    elements.forEach(el => el.remove())
  }

  aggressiveCleanup() {
    // ç´§æ€¥å†…å­˜æ¸…ç†
    const allModules = Array.from(this.moduleCache.keys())
    const nonEssentialModules = allModules.filter(id => {
      const info = this.moduleCache.get(id)
      return !info.isPersistent && !info.isCurrentlyVisible
    })

    nonEssentialModules.forEach(moduleId => {
      this.unloadModule(moduleId)
    })
  }

  registerModule(moduleId, module, options = {}) {
    this.moduleCache.set(moduleId, {
      module,
      lastUsed: Date.now(),
      isPersistent: options.persistent || false,
      isCurrentlyVisible: options.visible || false,
      cleanup: options.cleanup
    })
  }

  markModuleUsed(moduleId) {
    const moduleInfo = this.moduleCache.get(moduleId)
    if (moduleInfo) {
      moduleInfo.lastUsed = Date.now()
    }
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const memoryManager = new MemoryManager()

// æ³¨å†Œæ¨¡å—æ—¶æä¾›æ¸…ç†å‡½æ•°
memoryManager.registerModule('heavy-chart', chartModule, {
  persistent: false,
  cleanup: async () => {
    // æ¸…ç†å›¾è¡¨å®ä¾‹
    chartModule.destroy()
    // æ¸…ç†äº‹ä»¶ç›‘å¬å™¨
    chartModule.removeAllListeners()
  }
})
```

### é”™è¯¯æ¢å¤å’Œé™çº§ç­–ç•¥

```javascript
// é”™è¯¯æ¢å¤ç®¡ç†å™¨
class ErrorRecoveryManager {
  constructor() {
    this.failedModules = new Map()
    this.retryStrategies = new Map()
    this.fallbackComponents = new Map()
    
    this.setupGlobalErrorHandling()
  }

  setupGlobalErrorHandling() {
    // æ•è·åŠ¨æ€å¯¼å…¥é”™è¯¯
    window.addEventListener('unhandledrejection', (event) => {
      if (event.reason && event.reason.message && event.reason.message.includes('Loading chunk')) {
        event.preventDefault()
        this.handleChunkLoadError(event.reason)
      }
    })

    // æ•è·è„šæœ¬åŠ è½½é”™è¯¯
    window.addEventListener('error', (event) => {
      if (event.target.tagName === 'SCRIPT') {
        this.handleScriptError(event.target.src)
      }
    })
  }

  async handleChunkLoadError(error) {
    const chunkId = this.extractChunkId(error.message)
    
    if (chunkId) {
      await this.retryChunkLoad(chunkId)
    }
  }

  async retryChunkLoad(chunkId, maxRetries = 3) {
    const failureInfo = this.failedModules.get(chunkId) || { count: 0, lastAttempt: 0 }
    
    if (failureInfo.count >= maxRetries) {
      return this.loadFallback(chunkId)
    }

    // æŒ‡æ•°é€€é¿é‡è¯•
    const delay = Math.min(1000 * Math.pow(2, failureInfo.count), 10000)
    
    await new Promise(resolve => setTimeout(resolve, delay))

    try {
      // æ¸…é™¤ç¼“å­˜å¹¶é‡æ–°åŠ è½½
      await this.clearChunkCache(chunkId)
      const module = await import(/* webpackChunkName: "[request]" */ chunkId)
      
      // é‡è¯•æˆåŠŸï¼Œæ¸…é™¤å¤±è´¥è®°å½•
      this.failedModules.delete(chunkId)
      return module
    } catch (retryError) {
      failureInfo.count++
      failureInfo.lastAttempt = Date.now()
      this.failedModules.set(chunkId, failureInfo)
      
      console.warn(`Retry ${failureInfo.count} failed for chunk ${chunkId}:`, retryError)
      
      if (failureInfo.count >= maxRetries) {
        return this.loadFallback(chunkId)
      }
      
      return this.retryChunkLoad(chunkId, maxRetries)
    }
  }

  async clearChunkCache(chunkId) {
    // æ¸…é™¤æµè§ˆå™¨ç¼“å­˜
    if ('caches' in window) {
      const cacheNames = await caches.keys()
      for (const cacheName of cacheNames) {
        const cache = await caches.open(cacheName)
        const requests = await cache.keys()
        
        for (const request of requests) {
          if (request.url.includes(chunkId)) {
            await cache.delete(request)
          }
        }
      }
    }

    // æ¸…é™¤ webpack æ¨¡å—ç¼“å­˜
    if (typeof __webpack_require__ !== 'undefined' && __webpack_require__.cache) {
      Object.keys(__webpack_require__.cache).forEach(key => {
        if (key.includes(chunkId)) {
          delete __webpack_require__.cache[key]
        }
      })
    }
  }

  async loadFallback(chunkId) {
    const fallback = this.fallbackComponents.get(chunkId)
    
    if (fallback) {
      console.info(`Loading fallback for failed chunk: ${chunkId}`)
      return fallback
    }

    // é€šç”¨é™çº§ç»„ä»¶
    return {
      default: () => React.createElement('div', {
        className: 'error-fallback',
        children: [
          React.createElement('h3', null, 'å†…å®¹æš‚æ—¶æ— æ³•åŠ è½½'),
          React.createElement('p', null, 'è¯·åˆ·æ–°é¡µé¢é‡è¯•'),
          React.createElement('button', {
            onClick: () => window.location.reload()
          }, 'åˆ·æ–°é¡µé¢')
        ]
      })
    }
  }

  registerFallback(chunkId, fallbackComponent) {
    this.fallbackComponents.set(chunkId, fallbackComponent)
  }

  extractChunkId(errorMessage) {
    // ä»é”™è¯¯æ¶ˆæ¯ä¸­æå– chunk ID
    const match = errorMessage.match(/Loading chunk (\d+) failed/)
    return match ? match[1] : null
  }

  // ç½‘ç»œçŠ¶æ€é€‚åº”æ€§åŠ è½½
  async adaptiveLoad(moduleId) {
    const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection
    
    if (connection) {
      const { effectiveType, downlink } = connection
      
      // æ ¹æ®ç½‘ç»œçŠ¶å†µé€‰æ‹©åŠ è½½ç­–ç•¥
      if (effectiveType === '2g' || downlink < 0.5) {
        // æ…¢ç½‘ç»œï¼šåŠ è½½è½»é‡ç‰ˆæœ¬
        return this.loadLightVersion(moduleId)
      } else if (effectiveType === '3g' || downlink < 2) {
        // ä¸­ç­‰ç½‘ç»œï¼šæ ‡å‡†ç‰ˆæœ¬
        return this.loadStandardVersion(moduleId)
      } else {
        // å¿«ç½‘ç»œï¼šå®Œæ•´ç‰ˆæœ¬
        return this.loadFullVersion(moduleId)
      }
    }

    // é»˜è®¤åŠ è½½æ ‡å‡†ç‰ˆæœ¬
    return this.loadStandardVersion(moduleId)
  }

  async loadLightVersion(moduleId) {
    try {
      return await import(`${moduleId}/light`)
    } catch (error) {
      console.warn(`Light version not available for ${moduleId}, loading standard version`)
      return this.loadStandardVersion(moduleId)
    }
  }

  async loadStandardVersion(moduleId) {
    return import(moduleId)
  }

  async loadFullVersion(moduleId) {
    try {
      return await import(`${moduleId}/full`)
    } catch (error) {
      console.warn(`Full version not available for ${moduleId}, loading standard version`)
      return this.loadStandardVersion(moduleId)
    }
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const errorRecovery = new ErrorRecoveryManager()

// æ³¨å†Œé™çº§ç»„ä»¶
errorRecovery.registerFallback('dashboard', {
  default: () => React.createElement('div', null, 'ä»ªè¡¨æ¿æš‚æ—¶ä¸å¯ç”¨')
})

// åœ¨ç»„ä»¶ä¸­ä½¿ç”¨é€‚åº”æ€§åŠ è½½
const AdaptiveComponent = () => {
  const [Component, setComponent] = useState(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState(null)

  useEffect(() => {
    errorRecovery.adaptiveLoad('./components/HeavyComponent')
      .then(module => {
        setComponent(() => module.default)
        setLoading(false)
      })
      .catch(err => {
        setError(err)
        setLoading(false)
      })
  }, [])

  if (loading) return <div>Loading...</div>
  if (error) return <div>Error loading component</div>
  if (Component) return <Component />
  
  return null
}
```

## å‚è€ƒèµ„æº
### å®˜æ–¹æ–‡æ¡£

- [Webpack Code Splitting](https://webpack.js.org/guides/code-splitting/)
- [React.lazy](https://reactjs.org/docs/code-splitting.html)
- [Vue Async Components](https://vuejs.org/guide/components/async.html)
- [Dynamic Imports](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#dynamic_imports)

### å·¥å…·æ¨è

- [webpack-bundle-analyzer](https://github.com/webpack-contrib/webpack-bundle-analyzer)
- [source-map-explorer](https://github.com/danvk/source-map-explorer)
- [bundlephobia](https://bundlephobia.com/)
- [Bundle Buddy](https://bundle-buddy.com/)

### å­¦ä¹ èµ„æº

- [Web Performance Optimization](https://developers.google.com/web/fundamentals/performance)
- [JavaScript Performance](https://developer.mozilla.org/en-US/docs/Web/Performance)
- [Modern Web App Performance](https://web.dev/performance/)

---

> ğŸ’¡ **æç¤º**ï¼šä»£ç åˆ†å‰²æ˜¯ä¸€ä¸ªæ¸è¿›å¼çš„ä¼˜åŒ–è¿‡ç¨‹ï¼Œå»ºè®®ä»è·¯ç”±çº§åˆ†å‰²å¼€å§‹ï¼Œç„¶åæ ¹æ®å®é™…éœ€æ±‚é€æ­¥ç»†åŒ–åˆ°ç»„ä»¶çº§å’ŒåŠŸèƒ½çº§åˆ†å‰²ï¼
